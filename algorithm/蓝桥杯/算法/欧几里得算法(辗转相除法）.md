

# GCD（求最大公约数）
 > gcd(a % b)= gcd(b,a % b)
 
 **欧几里得算法**（辗转相除法）是求两个正整数最大公约数（GCD）的经典算法，基于核心原理：  

---

### 算法步骤

1. 用较大数除以较小数，得到余数
2. 用除数替换被除数，余数替换除数
3. 重复直到余数为0，此时除数即为最大公约数


**示例**：求 gcd(48, 18)

```
48 ÷ 18 = 2 余 12  
18 ÷ 12 = 1 余 6  
12 ÷ 6 = 2 余 0  
→ 最大公约数为 6
```

```c++
#include <iostream>
using namespace std;

int gcd(int a, int b) 
{
    if(b>a)
    {
        swap(a,b)
    }
    while (b != 0) {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}

int main() {
    int x, y;
    cin >> x >> y;
    cout << gcd(x, y);
    return 0;
}
```

# LCM(求最小公倍数)
> lcm(a,b) = abs(a\ gcd(a,b)\*b)

```c++
#include <iostream>
#include <cmath>    // 用于abs()
using namespace std;

int gcd(int a, int b) {
    while (b != 0) 
    {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}

int lcm(int a, int b) {
    if (a == 0 || b == 0) return 0; // 处理零的情况
    return abs(a / gcd(a, b) * b);  // 先除后乘防溢出
}

int main() {
    int x, y;
    cin >> x >> y;
    cout << lcm(x, y);
    return 0;
}
```
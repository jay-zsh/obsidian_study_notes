#### **本章学习目标**
理解事务的概念和ACID特性，识别并发操作可能导致的数据不一致性问题，掌握封锁机制的原理和封锁协议如何解决这些问题。

---

### **`★★★ 9.1 事务`**

#### **1. 事务是什么？**
-   **通俗理解**：事务是用户定义的一个**数据库操作序列**，这些操作要么**全部执行，要么全部不执行**，是一个不可分割的工作单位。
-   **经典例子**：**银行转账**。从A账户转账100元到B账户，这个操作包含两个步骤：
    1.  A账户余额减少100元。
    2.  B账户余额增加100元。
    -   这两个步骤必须作为一个整体，不能只发生第一步而第二步失败。

#### **2. 事务的ACID特性（事务的四大核心特性）**
这是事务理论的基石，必须牢记。

-   **`A - 原子性`**：
    -   **定义**：事务中的所有操作是一个不可分割的原子单位。事务要么全部成功（提交），要么全部失败（回滚）。
    -   **保障机制**：由数据库管理系统的**事务管理子系统**和**恢复管理子系统**负责。通过**日志**记录操作，失败时根据日志**回滚**。

-   **`C - 一致性`**：
    -   **定义**：事务的执行必须使数据库从一个**一致性状态**转变到另一个**一致性状态**。
    -   **通俗理解**：事务要保证数据库的**完整性约束**不被破坏。比如转账前后，A和B的总金额应该不变。
    -   **注意**：一致性是应用程序和数据库系统**共同维护**的。应用程序负责发出正确的事务（业务逻辑正确），DBMS通过原子性、隔离性和持久性来保证一致性的实现。

-   **`I - 隔离性`**：
    -   **定义**：一个事务的执行**不能被其他事务干扰**。并发执行的各个事务之间不能互相干扰。
    -   **通俗理解**：即使多个事务在同时运行，对每个事务来说，都感觉不到有其他事务在并发执行。
    -   **保障机制**：由DBMS的**并发控制子系统**负责，通常通过**封锁机制**实现。**这是本章的重点。**

-   **`D - 持久性`**：
    -   **定义**：一旦事务**提交**，它对数据库中数据的改变就是**永久性的**，即使后续系统发生故障也不会丢失。
    -   **保障机制**：由DBMS的**恢复管理子系统**负责。通过将数据变更**写入日志并持久化到硬盘**来实现。即使数据本身还没写回硬盘就宕机，重启后也能根据日志重新执行（重做）已提交的事务。

#### **3. 事务的状态与SQL命令**
-   **事务开始**：在MySQL中，`BEGIN` 或 `START TRANSACTION` 语句标志一个事务的开始。有些数据库也默认每条SQL都是一个事务（自动提交模式，MySQL默认是，可用 `SET autocommit=0` 关闭）。
-   **事务提交**：`COMMIT`。提交后，所有修改永久生效。
-   **事务回滚**：`ROLLBACK`。撤销事务中进行的所有修改，回到事务开始时的状态。

---

### **`★★ 9.2 并发操作的可能问题`**

如果不对并发事务进行控制，即使每个事务单独执行都是正确的，它们并发执行时也可能破坏数据库的一致性。主要有三类问题：

1.  **`丢失修改`**
    -   **场景**：两个事务T1和T2**同时读入同一数据并修改**，T2的提交结果覆盖了T1的提交结果，导致T1的修改丢失。
    -   **例子**：
        -   T1：读余额A=1000，A=A-100，写回A=900。
        -   T2：读余额A=1000，A=A-200，写回A=800。
        -   如果执行顺序不当，最终结果可能是A=800，T1的扣款100元丢失了。

2.  **`不可重复读`**
    -   **场景**：事务T1读取某个数据后，事务T2**更新**了该数据并提交，T1再次读取该数据时，值已改变。
    -   **例子**：
        -   T1第一次读余额A=1000。
        -   T2将A改为800并提交。
        -   T1第二次读余额A=800。
        -   在同一个事务T1内，两次读取同一数据A，结果却不一致。

3.  **`读“脏”数据`**
    -   **场景**：事务T1修改了某个数据但尚未提交，事务T2读取了这个**未提交的**数据。之后T1被回滚，T2读到的就是一个不存在的数据（“脏数据”）。
    -   **例子**：
        -   T1将余额A从1000改为900（未提交）。
        -   T2读A=900。
        -   T1因为某种原因回滚，A变回1000。
        -   此时T2读到的900就是一个“脏数据”。

**总结**：并发控制要解决的核心就是这三个问题。

---

### **`★★★ 9.3 封锁机制`**

封锁是实现事务隔离性，从而解决并发问题的主要技术。

#### **1. 基本封锁类型**
-   **`排它锁`**：又称**写锁，X锁**。
    -   **规则**：若事务T对数据对象A加上X锁，则**只允许T读取和修改A**，其他事务**不能再对A加任何锁**，直到T释放A上的锁。
    -   **用途**：用于修改数据。保证在修改一个数据时，其他事务无法读或写它。

-   **`共享锁`**：又称**读锁，S锁**。
    -   **规则**：若事务T对数据对象A加上S锁，则**T可以读A但不能修改A**，其他事务**只能再对A加S锁**，而不能加X锁，直到T释放A上的S锁。
    -   **用途**：用于读取数据。保证在读取一个数据时，其他事务可以同时读，但不能写它。

**兼容性矩阵**：
| 当前锁模式 | X锁 | S锁 | 无锁 |
| :--- | :---: | :---: | :---: |
| **请求X锁** | 不兼容 | 不兼容 | 兼容 |
| **请求S锁** | 不兼容 | 兼容 | 兼容 |

#### **2. 封锁协议：如何加锁解锁**
光有锁的类型不够，还需要约定何时加锁、何时释放，这就是封锁协议。

-   **`一级封锁协议`**：
    -   **规则**：事务T在**修改**数据R之前必须先对其加**X锁**，直到事务结束（提交或回滚）才释放。
    -   **解决的问题**：防止**丢失修改**。
    -   **未解决问题**：不要求读加锁，所以不能保证可重复读和不读脏数据。

-   **`二级封锁协议`**：
    -   **规则**：在一级封锁协议基础上，增加：事务T在**读取**数据R之前必须先对其加**S锁**，**读完后即可释放S锁**（不必等到事务结束）。
    -   **解决的问题**：防止**丢失修改**和**读“脏”数据**（因为读脏数据需要读未提交的数据，而未提交的数据上有X锁，S锁与X锁不兼容，所以读操作会被阻塞，直到X锁释放即事务提交）。
    -   **未解决问题**：由于S锁读完就释放，所以不能保证**可重复读**。

-   **`三级封锁协议`**：
    -   **规则**：在一级封锁协议基础上，增加：事务T在**读取**数据R之前必须先对其加**S锁**，直到**事务结束**才释放。
    -   **解决的问题**：防止**丢失修改**、**读“脏”数据**和**不可重复读**。因为S锁一直持有，其他事务无法获取X锁来修改数据，所以同一事务内多次读取结果一致。

#### **3. 活锁与死锁**
-   **`活锁`**：某个事务**永远处于等待状态**，可能是因为调度策略不公平，总是批准其他事务的锁请求。
    -   **解决**：采用**先来先服务**的队列策略。

-   **`死锁`**：**`核心难点`**
    -   **场景**：两个或以上事务都**互相等待对方释放锁**，导致所有事务都无法继续执行。
    -   **例子**：
        -   T1锁定了数据A，请求锁定数据B。
        -   T2锁定了数据B，请求锁定数据A。
        -   T1等待T2释放B，T2等待T1释放A，形成循环等待，死锁发生。
    -   **解决死锁的两类方法**：
        1.  **预防死锁**：通过协议（如一次封锁法、顺序封锁法）破坏死锁产生的条件。
        2.  **死锁的诊断与解除**：允许死锁发生，但系统定期检测。一旦检测到死锁，就**选择一个代价最小的事务将其回滚**，释放其持有的锁，使其他事务得以继续运行。这是DBMS更常用的方法。

---

### **本章总结与复习建议**

-   **核心概念**：深刻理解**事务的ACID特性**，尤其是**隔离性**的意义。
-   **核心问题**：能清晰阐述**丢失修改、不可重复读、读脏数据**这三个并发问题的场景。
-   **核心机制**：掌握**X锁和S锁**的含义及兼容性，理解**三级封锁协议**各自能解决什么问题。
-   **联系实际**：在MySQL中，你可以使用 `SELECT ... FOR UPDATE` 语句加X锁，使用 `SELECT ... LOCK IN SHARE MODE` 加S锁，并设置不同的事务隔离级别来观察并发控制的效果。

这一章的理论是构建高并发、高可靠应用的基础。理解这些原理，对于后续设置数据库事务隔离级别、处理并发bug都至关重要。如果有任何具体场景的分析需求，我们可以一起讨论。
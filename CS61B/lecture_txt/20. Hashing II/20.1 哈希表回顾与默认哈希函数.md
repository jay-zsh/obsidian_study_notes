# 20.1 哈希表回顾与常规哈希函数

"关键在于我们拥有大量短小的链表。" —— Hug教授

## 哈希表回顾与常规哈希函数

让我们继续理解哈希机制。我们已经见识过集合（Set）和映射（Map）的实现方式：

1. **基于红黑树的方法**：TreeSet/TreeMap
    
    • 要求元素具备可比性（需定义大小关系）
    
    • 对数时间复杂度
    
2. **基于哈希表的方法**：HashSet/HashMap
    
    • 若哈希码能良好分散元素（低碰撞率），可实现常数时间操作
    

哈希表的核心思想是将任意数据类型（如字符串或其他对象）转换为称为哈希码的数值。例如字符串"Mihir"可被转换为-2101281024。

**冷知识**：该整数范围约在±20亿之间（Java整型取值范围），共有约40亿（即2^32）个可能值。若对其原理感兴趣，请选修CS 61C课程！

获取哈希码后，我们需要将其转换为桶编号（即确定将新条目存入哪个链表）。以初始示例为例，我们使用`Math.floorMod(x, 4)`（因底层桶数组长度为4）。

将"Mihir"的哈希码-2101281024对4取模后得0。这意味着我们将数据"Mihir"存入0号桶对应的链表。

> 本质上，Java哈希表可视为由多个链表构成的数组（每个链表对应一个桶），通过合理利用这些链表实现更优性能。

但应设置多少个链表/桶？这个问题至关重要，因为随着元素不断插入，链表长度必然增长，进而影响哈希表操作的时间复杂度。

例如，假设插入"Mihir"、"Mirchandani"、"loves"和"61B"等字符串的哈希码均能被4整除，这些元素将被集中存入0号桶的链表。此时查找操作的耗时将退化为线性时间，这与哈希表快速查找的承诺背道而驰。

此前我们讨论过动态调整链表数量的策略。当负载因子（N/M，N为元素总数，M为桶数量）超过特定阈值时（Java默认采用0.75），我们会调整底层数组大小。这种机制能有效减少碰撞概率。只要元素分布均匀，各桶对应的链表长度将保持较短，从而保证平均常数时间复杂度！

**示例**：若哈希表负载因子为3，且`hashCode()`函数能均匀分布元素，则每个桶平均存储3个元素，此时查找操作耗时保持为Θ(1)。

---

## 数据结构时间复杂度对比

| 操作\数据结构        | 茂密二叉搜索树 | 固定大小的分离链接哈希表 | 动态调整的分离链接哈希表 |
|---------------------|----------------|-------------------------|-------------------------|
| contains(x)         | Θ(log N)       | Θ(N)                    | Θ(1)                    |
| add(x)              | Θ(log N)       | Θ(N)                    | Θ(1)                    |


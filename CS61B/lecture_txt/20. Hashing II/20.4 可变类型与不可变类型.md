20.4 可变类型与不可变类型
---

## 不可变数据类型

不可变数据类型指实例化后无法通过任何可观测方式改变其状态的数据类型。

示例：
- 可变类型：ArrayDeque、渗透模型（Percolation）
- 不可变类型：Integer、String、Date

```java
public class Date {
   public final int month;
   public final int day;
   public final int year;
   private boolean contrived = true;
   public Date(int m, int d, int y) {
       month = m; day = d; year = y;
   }
}
```

`final` 关键字可辅助编译器确保不可变性：
- `final` 变量仅允许赋值一次（通过构造函数或初始化器）
- `final` 既非不可变性的充分条件也非必要条件

---

### 不可变性的优劣势分析

**优势**：降低认知负担；避免错误并简化调试
- 类比：不可变类如同具有固定按钮和观测窗口的装置，操作结果始终可预测

**劣势**：任何状态变更都需要创建新对象
- 示例：字符串拼接效率低下

![[9e834996f7537c8ab19fde65d32fe8ed_MD5.jpg]]

---

## 可变类型

---

### 可变对象作为HashSet键

理论上可以创建 `HashSet<List>`，但以下操作将产生异常现象：
1. 将列表存入HashSet
2. 后续修改该列表

**关键准则**：切勿修改作为哈希键使用的对象，否则将导致错误结果和数据丢失（详见[哈希II课程幻灯片](https://docs.google.com/presentation/d/1U_-RQCJB3j9B-k-kY8I4nS-FuxIvO8EgVIrOthx2InU/edit#slide=id.g2165b69ef3f_0_291)的完整图解说明）

---

### Java标准库中HashSet/Map的实现机制

本小节简要解析Java官方实现的HashSet与HashMap源码结构。Hug教授通过代码走查展示了以下核心设计：
- 哈希桶的动态扩容机制
- 链表转红黑树的阈值设定（Java8+）
- 负载因子与再哈希算法的协同运作

（注：具体实现细节涉及开放寻址法和链地址法的混合使用，建议结合源码注释深入理解）
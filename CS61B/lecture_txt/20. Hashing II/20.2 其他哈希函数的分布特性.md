# 20.2 其他哈希函数的分布特性

哈希映射/表具备快速查找能力，但其"超能力"背后是哈希函数的支撑。

---

## 其他哈希函数的分布特性

假设我们的`hashCode()`实现仅返回0：

```java
@Override
public int hashCode() {
    return 0;
}
```

我们预期的分布情况如何？

---

## 改进分布的方法

为了获得更均匀的分布，可以采用[前一章节](https://cs61b-2.gitbook.io/cs61b-textbook/20.-hashing-ii/20.1-hash-table-recap-default-hash-function)中提到的模运算方案。假设哈希表有4个桶（对应4个链表和索引{0, 1, 2, 3}），模运算虽然不直接在`hashCode()`中实现，但会在哈希表内部自动执行以确保元素存入对应桶。哈希码实际上可以是40亿个唯一值中的任意整数！

通过模运算，我们确保哈希码生成的数字既能作为索引，又能明确标识应该存入的链表。当批量添加数字时，可以看到元素在链表中呈现均匀分布，从而实现恒定时间复杂度的查找。

```java
@Override
public int hashCode() {
    return num;
}
```

这个哈希函数将产生更均匀的分布！不同`num`值的对象现在会分散到各个桶中，而非全部集中在0号桶。如果类未显式覆盖`hashCode()`方法，Java将使用默认实现（返回对象内存地址作为哈希码）！

---

## 自定义哈希函数的必要性

若默认哈希函数已具备良好分布性，为何还需自定义实现？实际上，默认函数确实具备优秀分布特性——它依赖不同对象在内存中的不同位置，而内存地址本质上是随机的。这种随机性保证了对象会被分配到哈希表中的随机索引位置。

这引出一个有趣的问题：既然默认哈希码已实现良好分布，为何还需自定义哈希函数？我们将在[下一章节](https://cs61b-2.gitbook.io/cs61b-textbook/20.-hashing-ii/20.3-contains-and-duplicate-items)深入探讨。
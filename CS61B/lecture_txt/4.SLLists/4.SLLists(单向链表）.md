# 4. SLLists

---

在第三章中，我们构建了`IntList`类，这种列表数据结构在技术上可以实现列表的所有功能。然而在实际使用中，`IntList`存在使用不够直观的问题，导致代码可读性和可维护性降低。

根本问题在于`IntList`属于我所说的**裸露递归**数据结构。要正确使用`IntList`，程序员必须理解并运用递归思想，即使进行简单的列表操作也不例外。这对新手程序员构成了使用障碍，同时也可能引发各类棘手错误，具体取决于`IntList`类提供的辅助方法。

基于`IntList`的使用经验，我们将构建更贴近现代编程语言列表实现的新类`SLList`。通过逐步改进的方式实现这一目标。

---

## 改进#1：品牌重塑

我们之前的`IntList`类如下（省略辅助方法）：

```java
public class IntList {
    public int first;
    public IntList rest;

    public IntList(int f, IntList r) {
        first = f;
        rest = r;
    }
...
```

首先进行简单的重命名并移除辅助方法：

```java
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

---

## 改进#2：层级管理

为了解决`IntNode`难以直接操作的问题，我们将创建用户直接交互的`SLList`类：

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }
}
```

比较两种结构的创建方式即可看出`SLList`的优势：

```java
IntList L1 = new IntList(5, null);
SLList L2  = new SLList(5);
```

`SLList`向用户隐藏了空链接的底层细节。现在添加`addFirst`和`getFirst`方法：

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }

    /** 在列表前端添加元素 */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
    
    /** 获取列表首元素 */
    public int getFirst() {
        return first.item;
    }
}
```

使用对比：

```java
SLList L = new SLList(15);
L.addFirst(10);
L.addFirst(5);
int x = L.getFirst();
```

与传统方式：

```java
IntList L = new IntList(15, null);
L = new IntList(10, L);
L = new IntList(5, L);
int x = L.first;
```

`SLList`作为中间层，有效防止了用户直接操作中间节点带来的风险。

---

## 改进#3：访问控制

通过`private`关键字限制直接访问：

```java
public class SLList {
    private IntNode first;
...
```

私有成员只能在类内部访问，外部类尝试访问将编译失败：

```java
public class SLLTroubleMaker {
    public static void main(String[] args) {
        SLList L = new SLList(15);
        L.addFirst(10);
        L.first.next.next = L.first.next; // 编译错误
    }
}
```

`private`关键字在大型项目中能有效隔离实现细节，`public`方法则需保证永久兼容性。

---

## 改进#4：嵌套类

将`IntNode`作为内部类：

```java
public class SLList {
    public static class IntNode {
        public int item;
        public IntNode next;
        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }

    private IntNode first; 
...
```

使用`static`关键字声明嵌套类可节省内存，当内部类无需访问外部类成员时推荐使用。

---

## 添加末端插入与尺寸计算

实现`addLast`和`size`方法：

```java
/** 在列表末端添加元素 */
public void addLast(int x) {
    IntNode p = first;
    while (p.next != null) {
        p = p.next;
    }
    p.next = new IntNode(x, null);
}

/** 递归计算尺寸的辅助方法 */
private static int size(IntNode p) {
    if (p.next == null) return 1;
    return 1 + size(p.next);
}

public int size() {
    return size(first);
}
```

---

## 改进#5：缓存机制

通过维护尺寸变量提升性能：

```java
public class SLList {
    private IntNode first;
    private int size;

    public SLList(int x) {
        first = new IntNode(x, null);
        size = 1;
    }

    public void addFirst(int x) {
        first = new IntNode(x, first);
        size += 1;
    }
...
```

---

## 改进#6：空列表处理

通过哨兵节点消除特殊条件：

```java
public class SLList {
    private IntNode sentinel;
    private int size;

    /** 创建带哨兵的空列表 */
    public SLList() {
        sentinel = new IntNode(63, null); // 哨兵值可任意
        size = 0;
    }

    /** 更新后的addLast方法 */
    public void addLast(int x) {
        IntNode p = sentinel;
        while (p.next != null) {
            p = p.next;
        }
        p.next = new IntNode(x, null);
        size++;
    }
...
```

---

## 不变式保证

哨兵节点系统的不变式：

1. `sentinel`始终指向哨兵节点
2. 首元素（如果存在）位于`sentinel.next.item`
3. `size`变量始终反映准确元素数量

这些不变式提升了代码的可维护性和可靠性。哨兵节点的精妙之处将在实际项目（如Project 1）中充分体现，建议完成后续章节后再进行实践。
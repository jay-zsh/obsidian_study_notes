
---

### 类结构定义

```java
class Dog {
    public void bark() {
        System.out.println("Woof!");
    }
}

class ShowDog extends Dog {
    @Override
    public void bark() {
        System.out.println("ShowDog bark: Arf!");
    }
}
```


---

### 继承关系示意图

![](https://cs61b-2.gitbook.io/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FnAJGy8b3QssQgxGfwWyG%252Fimage.png%3Falt%3Dmedia%26token%3D2087b4a9-cddf-42f6-a59d-97343ad80439&width=300&dpr=4&quality=100&sign=d2250072&sv=2)

|类名|继承关系|方法特性|
|---|---|---|
|Dog|超类（父类）|基础bark方法|
|ShowDog|子类|覆盖bark方法|

---

## 动态方法选择三大规则

### 1. 类型兼容规则

```java
Dog myDog = new ShowDog(); // ✅ 合法
```

- 静态类型为父类时，可指向子类对象
- 编译器仅检查静态类型合法性

### 2. 编译期方法绑定

```java
Dog dog = new Dog();
dog.bark(); // 编译时绑定Dog.bark()

Object obj = new ShowDog();
// obj.bark(); ❌ 编译错误：Object无bark方法
```

### 3. 运行期动态绑定

```java
Dog polyDog = new ShowDog();
polyDog.bark(); // 运行时调用ShowDog.bark()
```

---

## 静态类型 vs 动态类型

### 对比表格

|特性|静态类型（编译时类型）|动态类型（运行时类型）|
|---|---|---|
|确定时机|变量声明时|对象实例化时|
|可变性|不可变|随对象改变|
|检查阶段|编译期检查|运行期检查|
|方法绑定|决定可调用方法范围|决定实际执行方法版本|
|示例|`Dog d = new ShowDog();` 中的Dog|`Dog d = new ShowDog();`中的ShowDog|

---

## 方法调用流程

### 动态选择过程

1. **创建对象**
    
    ```java
    Dog myPet = new ShowDog("Ace"); // 动态类型=ShowDog
    ```
    
2. **方法调用**
    
    ```java
    myPet.bark(); // JVM查找ShowDog的bark方法
    ```
    
3. **执行路径**
    
    - 检查对象实际类型的方法表
    - 选择最具体的实现版本（子类优先）

---

## 综合案例分析

### 代码示例

```java
public class Main {
    public static void main(String[] args) {
        Dog dog1 = new Dog();
        Dog dog2 = new ShowDog();
        Object obj = new ShowDog();

        dog1.bark(); // Woof!
        dog2.bark(); // ShowDog bark: Arf!
        // obj.bark(); ❌ 编译错误
    }
}
```

### 执行结果解析

|调用对象|静态类型|动态类型|输出结果|
|---|---|---|---|
|`dog1`|Dog|Dog|"Woof!"|
|`dog2`|Dog|ShowDog|"ShowDog bark: Arf!"|
|`obj`|Object|ShowDog|无法调用（编译阻止）|

---

## 重载与覆盖对比

### 核心差异表

|特性|方法重载（Overload）|方法覆盖（Override）|
|---|---|---|
|绑定时机|编译期静态绑定|运行期动态绑定|
|签名要求|必须修改参数列表|必须完全相同的方法签名|
|返回类型|可自由修改|协变返回类型（子类可返回更具体类型）|
|访问权限|无限制|子类方法访问权限 ≥ 父类|
|异常声明|无限制|子类方法异常 ≤ 父类|

---

> **关键记忆点**：动态方法选择是Java实现运行时多态的核心机制，通过方法表(Method Table)实现高效的类型派发。理解静态类型与动态类型的区别是掌握多态编程的基础。
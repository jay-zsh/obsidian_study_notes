## 核心概念对比

### 两种设计模式比较

| 特性     | 显式高阶函数（HoF）  | 子类型多态性       |
| ------ | ------------ | ------------ |
| 控制权    | 由外部函数逻辑控制    | 由对象自身方法决定    |
| 代码耦合度  | 低（业务逻辑与数据分离） | 高（数据与操作绑定）   |
| 扩展性    | 添加新比较器即可扩展   | 需要修改类继承体系    |
| 代码复用性  | 高（通用逻辑复用）    | 较低（每个类需实现方法） |
| 类型系统要求 | 依赖接口/函数式接口   | 依赖继承体系       |
| 典型应用场景 | 需要多种比较策略     | 固有比较逻辑       |

---

## 显式高阶函数实现

### Java接口定义

```java
@FunctionalInterface
public interface Comparator<T> {
    /** 比较函数：返回正数表示a > b */
    int compare(T a, T b);
}

@FunctionalInterface
public interface Stringifier<T> {
    /** 对象序列化函数 */
    String stringify(T obj);
}
```

### 工具类实现

```java
public class ObjectUtils {
    /** 通用比较打印工具 */
    public static <T> String printLarger(T x, T y, 
                                       Comparator<T> comp,
                                       Stringifier<T> stringifier) {
        return comp.compare(x, y) > 0 ? stringifier.stringify(x) 
                                     : stringifier.stringify(y);
    }
}
```

### 使用示例

```java
// 自定义比较规则
Comparator<Integer> intComparator = (a, b) -> a - b;
Stringifier<Integer> intStringifier = Object::toString;

System.out.println(ObjectUtils.printLarger(5, 3, intComparator, intStringifier)); // 输出5
```

---

## 子类型多态实现

### 类继承体系

```java
public abstract class ComparableEntity {
    /** 抽象比较方法 */
    public abstract boolean largerThan(ComparableEntity other);
    
    /** 抽象字符串化方法 */
    public abstract String str();
}

public class Student extends ComparableEntity {
    private final String name;
    private final int score;

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    @Override
    public boolean largerThan(ComparableEntity other) {
        // 类型安全检查
        if (!(other instanceof Student)) return false;
        return this.score > ((Student) other).score;
    }

    @Override
    public String str() {
        return String.format("Student{name=%s, score=%d}", name, score);
    }
}
```

### 多态调用示例

```java
Student alice = new Student("Alice", 90);
Student bob = new Student("Bob", 85);

System.out.println(alice.largerThan(bob) ? alice.str() : bob.str()); // 输出Alice信息
```

---

## 动态方法选择原理

```java
ComparableEntity a = new Student("Alice", 90);
ComparableEntity b = new Student("Bob", 85);

// 运行时根据实际类型调用Student类的largerThan实现
boolean result = a.largerThan(b); 
```

### 执行过程解析

1. **编译时检查**：验证`ComparableEntity`包含`largerThan`方法
2. **运行时查找**：通过对象头访问Student类方法表
3. **方法绑定**：选择`Student.largerThan()`的具体实现
4. **结果返回**：基于分数比较返回布尔值

---

## 设计选择建议

|场景|推荐模式|理由|
|---|---|---|
|需要多种比较策略|显式高阶函数|通过不同Comparator实现灵活切换比较逻辑|
|对象有固有排序规则|子类型多态|利用继承体系表达天然排序关系（如学生按成绩排序）|
|跨类统一处理|显式高阶函数|不同类对象可通过统一接口进行比较（如Student与Teacher比较）|
|需要维护对象封装性|子类型多态|比较逻辑属于对象核心职责时（如复数比较）|

> **关键原则**：优先使用接口组合（显式HoF），必要时再使用继承多态。遵循《Effective Java》第18条："Favor composition over inheritance"
# 34.4 总结

---

**突如其来的数学问题 1.**  
我们证明了  
$$N!∈Ω(N2N2)$$  
$$N!∈Ω(2N​2N​)$$  

---

**突如其来的数学问题 2.**  
我们证明了  
$$log(N!)∈Ω(NlogN)$$  
和  
$$NlogN∈Ω(log(N!))$$  
因此，  
$$log(N!)∈Θ(NlogN)$$  

---

**寻求排序下界。**  
我们已经发现多种排序算法能在  
$$Θ(NlogN)$$  
时间内完成执行。这引发了一个明显的问题：我们能否做得更好？让 TUCS（代表“终极比较排序”）成为比较项目并排序的最佳可能算法。我们知道 TUCS 的最坏情况运行时间是  
$$O(NlogN)$$  
因为我们已经知道几种最坏情况运行时间为  
$$Θ(NlogN)$$  
的算法，并且 TUCS 的最坏情况运行时间是  
$$Ω(N)$$  
因为我们必须至少查看每个项目。无需进一步讨论，目前的分析表明，我们可能能够在最坏情况时间上比  
$$Θ(NlogN)$$  
做得更好。  

---

**建立排序下界。**  
作为一个奇思妙想的练习，我们玩了一个名为“小狗-猫-狗”的游戏，其中我们必须识别三个盒子中哪个包含小狗、猫或狗。由于有  
$$3! = 6$$  
种排列，我们至少需要  
$$ceil(lg(6)) = 3$$  
个问题来解决答案。换句话说，如果在有 6 个可能答案的 20 个问题游戏中，我们必须至少问 3 个问题才能确保得到正确答案。由于通过比较排序是解决小狗-猫-狗问题的一种方式，因此小狗-猫-狗问题的比较次数下界也适用于排序。给定 N 个项目，有  
$$N!$$  
种排列，意味着我们需要  
$$lg(N!)$$  
个问题来赢得小狗-猫-狗游戏，进而，我们需要至少  
$$lg(N!)$$  
个是/否问题来排序 N 个项目。由于  
$$log(N!) = Θ(NlogN)$$  
我们可以说，假设使用是/否问题的最佳排序算法需要  
$$Ω(NlogN)$$  
个是/否问题。因此，没有基于比较的算法的最坏情况比较次数增长阶优于  
$$Θ(NlogN)$$  
次比较。
# 34.5 练习
---
## 事实性
1. 以下哪个函数在大Θ表示法下具有最慢的增长阶？
    - $$N \log N$$
    - $$\log N!$$
    - $$N^2$$
    - $$N! \log N!$$
2. 为了解决12个项目的puppy、cat、dog问题，根据讲座中使用的论证，理论上的最小比较次数是多少？请将答案四舍五入到最接近的整数。
3. 以下哪些陈述是正确的？
    - 最优排序算法最多需要$Θ(N \log N)$时间。
    - 不可能找到基于比较的排序算法，其比较次数少于$Θ(N \log N)$。
    - 不可能找到基于比较的排序算法，其运行时间少于$Θ(N \log N)$。
    - 不可能找到任何排序算法，其运行时间少于$Θ(N \log N)$。

问题1  
在讲座中，我们证明了$$\log N! \in \Theta(N \log N)$$。因此，$$N \log N$$和$$\log N!$$具有相同的增长阶，并且比$$N^2$$或$$N! \log N!$$慢。

问题2  
$$\lceil \log_2 12! \rceil = 29$$，基于讲座中的公式。

问题3  
- **最优排序算法最多需要$Θ(N \log N)$时间**。我们知道多种排序（如归并排序）在最坏情况下需要$Θ(N \log N)$时间，因此假设的“最佳”算法不可能比这更差。  
- **不可能找到基于比较的排序算法，其比较次数少于$Θ(N \log N)$**。这是讲座中证明的比较排序下界。  
- **不可能找到基于比较的排序算法，其运行时间少于$Θ(N \log N)$**。每次比较至少需要常数时间，因此基于比较排序的时间复杂度下界与比较次数相同。  
- **不可能找到任何排序算法，其运行时间少于$Θ(N \log N)$**。讲座中证明的下界仅适用于基于比较的排序；后续课程将展示如何通过非比较排序进一步降低时间复杂度。

---
## 元认知
1. 假设我们向`Arrays.sort`添加一个新方法，该方法接受一个字符串数组。`Arrays.sort(String[] x)`应该使用什么算法？

问题1  
快速排序。我们不需要稳定性，因为字符串仅在完全相同时通过`.equals`相等。因此，快速排序是最佳算法，因为它在经验上是最快的。
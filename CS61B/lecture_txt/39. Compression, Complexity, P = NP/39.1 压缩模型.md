# 39.1 压缩模型
---
## 比较压缩算法
在上一章中，我们看到了许多压缩方法。这引发了一个有趣的问题：对于给定的比特流，什么是最佳的压缩算法？

例如，考虑使用不同压缩格式压缩《白鲸记》文本的情况。此时，`bzip2`提供了最佳的压缩效果。

![](0c62fd75d0f2243c8cea0e7e479077e4_MD5.jpg)

然而，有人可能认为针对`mobydick.txt`的最佳压缩算法如下：

```
D(B):
    if input == 0:
        return "Call me Ishamel. ...."
    else:
        return the text as is
```

使用此解压缩函数，我们可以将整部《白鲸记》压缩为单个比特！

但这种方法存在一个问题。如果我们将解压缩算法代码作为压缩模型的一部分（回顾上一章的压缩模型2），会发现《白鲸记》并未被压缩至一比特——实际上所需比特数比原始文本更多！

---
## 解压缩算法
最终，压缩算法的目标是找到能生成所需较长比特序列的短比特序列。该问题可形式化表述如下：

- 给定比特序列`B`，找到较短的序列`DA + C(B)`，使其输入解释器时生成`B`。其中`DA`代表解压缩算法的比特，`C(B)`代表`B`的压缩版本。

![](bd4e4a3e64df87a13eebf35088a2d714_MD5.jpg)
---
## 改进压缩
回顾上一章的`HugPlant`示例。使用霍夫曼编码可实现25%的压缩率。

然而，通过一种暂称为`MysteryX`的算法，我们可将`HugPlant.bmp`压缩至29,432比特！这实现了0.35%的压缩率。在长度为8,389,5948,389,594的2838959428389594个可能比特流中，仅2836015128360151分之一能达到此压缩率。

![](8e943531d66576430473c9bfd7f5e611_MD5.jpg)

`MysteryX`究竟是什么？它其实就是生成`.bmp`文件的Java代码`HugPlant.java`！回归自解压比特模型，我们看到了代码和解释器在压缩中的强大能力。这引出了两个关键问题：

- **可理解的压缩**：给定目标比特流`B`，能否创建输出有用、可读Java代码的算法？
- **最优压缩**：给定目标比特流`B`，能否找到输出该比特流的*最短*可能程序？
# 14.4 加权快速合并（WQU）

改进快速合并算法的关键在于一个重要洞见：每次调用`find`方法时，我们都需要沿着树结构上溯至根节点。因此，树的高度越矮，操作速度越快！

**新规则**：每次执行`connect`操作时，始终将较小树的根节点连接到较大树的根节点。

遵循此规则可确保树的最大高度为logN（其中N为不相交集合中元素总数）。这将如何影响`connect`和`isConnected`方法的时间复杂度？

Hug教授关于加权快速合并的图解说明

通过示例说明该算法的优势。假设需要合并下方两个集合T1和T2：

![[PANG/ef8b4e28b1ae8b28f70b7c2729b096ba_MD5.jpg]]

我们有两种连接方式：

1. 将T1链接到T2  
2. 将T2链接到T1

![[PANG/17ddaffdf1abf833c656e5c8de3c4782_MD5.jpg]]

**第二种方式更优**，因为其高度仅为2而非3。根据新规则，我们也会选择第二种方式——T2（包含3个元素）比T1（包含6个元素）更小。

通过树的元素数量判定大小关系。因此在连接两棵树时，我们需要知道它们的规模（或称权重）。我们可以在根节点存储此信息，将原来的`-1`替换为`-(树的大小)`。

---

**最大高度：Log N**

遵循上述规则可确保所有树的**最大**高度为Θ(log N)，其中N代表不相交集合中的元素总数。**因此，**`**connect**`**和**`**isConnected**`**方法的时间复杂度上限为O(log N)。**

---

为什么是logN呢？视频提供了更直观的解释。这里给出一个可选的数学解释：假设元素x在树T1中，当且仅当T1被连接到另一棵树T2下方时，x的深度才会增加1。此时新树的规模至少是原T1的两倍（因为size(T2) ≥ size(T1)）。对于含x的树来说，这种规模翻倍最多发生log₂N次（因为2^log₂N = N）。每次翻倍增加一层高度→最大高度为log₂N。

---

您可能会疑惑为何不根据树的高度而非权重进行连接。实际上这会导致更复杂的实现，而最终得到的树高限制仍然是Θ(log N)。

---

### 总结与代码实现

实现方式 | 构造函数 | connect | isConnected
--- | --- | --- | ---
QuickUnion | Θ(N) | O(N) | O(N)
QuickFind | Θ(N) | Θ(N) | Θ(1)
Weighted Quick Union | Θ(N) | O(log N) | O(log N)


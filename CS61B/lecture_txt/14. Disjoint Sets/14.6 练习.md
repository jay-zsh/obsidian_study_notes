# 14.6 练习

---
## 事实类

1. [2016春季期中考试2第2题](https://drive.google.com/file/d/1GuTG5O-2SSudWgm47rIi4orkmmpU4Apa/view?usp=share_link)
    
2. [2015春季期中考试2第1d题](https://drive.google.com/file/d/1uE1QlF4YguWVp8m8UJ97R2xPC4b1NnQ5/view?usp=sharing)
    
3. 假设我们有如下带路径压缩的权重并查集。调用`isConnected(8, 9)`后，树的高度是多少？
    
![[0e89235301abb1703c5ad15295cb6867_MD5.jpg]]

---

### 问题1[]
[解答](https://drive.google.com/file/d/1KXLkjx1e8QPiu-waBJFwmcT5IToMHQK5/view?usp=sharing)链接在此处和课程网站。

---

### 问题2
[解答](https://drive.google.com/file/d/1IYt4VbzdX4dTekh6cYAC8tigpJ_LgljV/view?usp=sharing)链接在此处和课程网站。

---

### 问题3
最终树的高度为1。从`0`到`9`路径上的所有节点现在都将以`0`为父节点，同样从`0`到`8`路径上的所有节点也将以`0`为父节点。

---
## 概念类

1. 以下哪个数组可能表示有效的带权并查集结构？
    
    - `[8, 0, 4, 0, 0, 4, 0, 4, 2, 0]`
        
    - `[4, -8, 8, 2, 1, -2, 1, 1, 4, 5]`
        
    - `[3, 3, 5, 9, 3, 6, 3, 4, 1, -10]`
        
    - `[2, -10, 1, 1, 1, 1, 1, 2, 1, 7]`
        

---

### 问题
- `[8, 0, 4, 0, 0, 4, 0, 4, 2, 0]`：无效。存在循环 8 --> 2 --> 4 --> 0 --> 8
- `[4, -8, 8, 2, 1, -2, 1, 1, 4, 5]`：无效。最大高度4超过log₂(10)
- `[3, 3, 5, 9, 3, 6, 3, 4, 1, -10]`：无效。根节点9的树大小（不包含根节点3的子树）小于根节点3的树大小，因此连接时应让3成为9的父节点
- `[2, -10, 1, 1, 1, 1, 1, 2, 1, 7]`：有效

---
## 操作类

1. 定义全连接的权重并查集为所有元素处于同一集合的结构。对于6元素的全连接权重并查集，其高度的最大值和最小值是多少？
    
2. 假设存在高度为H的权重并查集，该结构中至少需要多少个元素？

---

### 问题1
最小高度始终为1（所有元素直连根节点），最大高度为2（取log₂6的下整）

---

### 问题2
已知H ≤ log₂N（N为元素总数），因此N ≥ 2ᴴ

---


## 元认知类

1. [2017春季期中考试2第3题](https://drive.google.com/file/d/1yWyRp7QTizspTp9dsKz5yxE6bSf9YUIi/view?usp=sharing)
    
2. 假设创建含N个元素的权重并查集后，进行M_C次连接操作和M_U次查询操作。使用大O符号表示该操作序列的时间复杂度
    
3. 使用问题2中的变量，描述一个能实现O(N + M_U + M_C)时间复杂度的操作序列
    
4. 编写带路径压缩的权重并查集的`int find(int p)`方法，需实现课堂描述的路径压缩：从根节点到目标节点路径上的所有节点都应将其父节点重置为根节点

---

### 问题1
[解答](https://drive.google.com/file/d/1b99XARlZxg3NMfeSAVt2yzDzwSEcASq3/view?usp=sharing)链接在此处和课程网站。

---

### 问题2
时间复杂度为O(N + (M_U + M_C)logN)。每个操作耗时logN，初始化N元素数组需O(N)

---

### 问题3
按顺序连接元素：`connect(0, 1)`, `connect(0, 2)`...`connect(0, N)`，形成高度为1的树，此时连接和查询操作均为常数时间

---

### 问题4

```java
public int find(int p) {
    int root = p;
    while (root != parent[root]) {
        root = parent[root];
    }
    
    while (p != root) {
        int newp = parent[p];
        parent[p] = root;
        p = newp;
    }
    
    return root;
}
```

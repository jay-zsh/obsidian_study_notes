# 14.5 带路径压缩的加权快速合并

加权快速合并算法已经非常优秀，但我们还能做得更好！

Hug教授对带路径压缩的加权快速合并的解析：

其精妙之处在于意识到：每次调用`find(x)`时，我们都必须遍历从`x`到根节点的路径。因此，在此过程中我们可以将访问的所有节点直接连接到根节点，而无需增加渐进时间复杂度。

通过在每次`find`调用中将路径上的所有节点连接到根节点，我们的树结构会随着每次调用变得更扁平。

值得注意的是**`connect(x, y)`和`isConnected(x, y)`总是会调用`find(x)`和`find(y)`**。因此，经过足够次数的`connect`或`isConnected`调用后，本质上所有元素都会直接指向其根节点。

延伸来看，从长期运行的角度分析，`connect`和`isConnected`的平均时间复杂度将变得**近乎常数级**！这被称为_分摊时间复杂度_。

更具体地说，对N个元素进行M次操作时，带路径压缩的WQU算法时间复杂度为O(N + M(lg*N))。其中lg*是[迭代对数](https://en.wikipedia.org/wiki/Iterated_logarithm)，在现实世界的数据规模下该值始终小于5。

---

### 总结

N：不相交集元素数量

| 实现方式                | `isConnected` | `connect`     |
|----------------------|---------------|---------------|
| 快速查找                | Θ(1)          | Θ(N)          |
| 快速合并                | O(N)          | O(N)          |
| 加权快速合并（WQU）        | O(log N)      | O(log N)      |
| 带路径压缩的WQU          | O(α(N))*      | O(α(N))*      |

*长期运行中表现为常数级时间复杂度

---

代码块示例：
```python
# 路径压缩实现示例
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])  # 递归路径压缩
    return parent[x]
```

表格注意事项：
1. 所有时间复杂度均为最坏情况分析
2. α(N)为反阿克曼函数，增长极其缓慢
3. 实际应用中带路径压缩的WQU接近常数时间复杂度
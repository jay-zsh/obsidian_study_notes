# 22.2 树的遍历

---

## 树~~迭代~~遍历

回忆我们如何遍历列表？存在一种自然的方式：从起点开始...持续前进。

有时也会采用特殊方式，如反向遍历列表。我们在[讨论课](https://sp19.datastructur.es/materials/discussion/disc05.pdf)中还编写过迭代器，用于跳过未填写描述的学生办公室队列。

那么如何遍历树？何为"正确"顺序？

在回答前，需避免使用"迭代"一词，改用"树遍历"或"树形遍历"。原因无他，唯约定俗成——或许因世人偏爱头韵修辞。

树遍历有哪些自然方式？与列表仅一种自然遍历不同，树主要有：

1. 层序遍历（广度优先搜索/BFS）
2. 深度优先遍历（含三种：前序、中序、后序/DFS）

以下图树为例演示不同遍历方式：

![](PANG/3ed88509f2ee1aaeac90ddb3c4b30d8f_MD5.jpg)  
同一棵树的不同遍历方式...

---

### 层序遍历

按层级从左至右遍历：  
层级0：D  
层级1：B → F  
层级2：A → C → E → G  
得序列：`D B F A C E G`

想象每层如书页文字逐行阅读。

**练习 17.2.1** 编写层序遍历代码（提示：需记录当前层级）

---

### 前序遍历

核心逻辑：  
1. 访问根节点（执行操作，如打印）  
2. 递归遍历左子树  
3. 递归遍历右子树  

从根节点D开始：  
打印D → 遍历左子树至B → 打印B → 遍历左子树至A → 打印A → 回溯至B → 遍历右子树至C → 打印C → 回溯至D → 遍历右子树至F...  
得序列：`D B A C F E G`

```java
preOrder(BSTNode x) {
    if (x == null) return;
    print(x.key)
    preOrder(x.left)
    preOrder(x.right)
}
```

---

### 中序遍历

核心逻辑：  
1. 递归遍历左子树  
2. 访问根节点  
3. 递归遍历右子树  

从D开始：  
遍历左子树至B → 遍历左子树至A → 打印A → 回溯至B → 打印B → 遍历右子树至C → 打印C → 回溯至D → 打印D → 遍历右子树至F...  
得序列：`A B C D E F G`

替代理解：  
输出 = [左子树元素] + D + [右子树元素]  
左子树元素 = [B的左子树] + B + [B的右子树] = A + B + C

```java
inOrder(BSTNode x) {
    if (x == null) return;    
    inOrder(x.left)
    print(x.key)
    inOrder(x.right)
}
```

---

### 后序遍历

核心逻辑：  
1. 递归遍历左子树  
2. 递归遍历右子树  
3. 访问根节点  

输出 = [左子树元素] + [右子树元素] + D  
左子树元素 = [B的左子树] + [B的右子树] + B = A + C + B  
得序列：`A C B E G F D`

```java
postOrder(BSTNode x) {
    if (x == null) return;    
    postOrder(x.left)
    postOrder(x.right)
    print(x.key)   
}
```
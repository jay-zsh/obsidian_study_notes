# 29.5 总结

![](PANG/7845be1da7ad33d4d8d597be5c0b12bb_MD5.jpg)

对目前为止涵盖的排序算法的总结。

---

### 概述

**逆序对。** 序列中无序元素对的数量。没有逆序对的数组是有序的。

**选择排序。** 一种排序方法是选择：反复识别最极端的元素并将其移动到数组未排序部分的末尾。这种算法的朴素实现是原地进行的。

**朴素堆排序。** 选择排序的一个变体是使用基于堆的优先队列（PQ）来排序项目。为此，将所有项目插入一个最大优先队列（MaxPQ），然后逐个移除它们。第一个移除的项目被放置在数组的末尾，下一个项目放置在末尾之前，依此类推，直到最后一个删除的项目被放置在数组的位置0。每次插入和删除需要$O(log N)$时间，并且有N次插入和删除，因此运行时间为$O(N log N)$。通过一些额外工作，我们可以证明堆排序在最坏情况下是$θ(N log N)$。这种朴素堆排序版本使用$θ(N)$空间用于优先队列。创建最大优先队列需要$O(N)$内存。也可以使用最小优先队列（MinPQ）代替。

**原地堆排序。** 在排序数组时，我们可以通过将数组本身视为堆来避免θ(N)的内存开销。为此，我们首先使用自底向上的堆构建方法堆化数组（耗时θ(N)）。然后我们反复删除最大项，将其与堆中的最后一项交换。随着时间的推移，堆从N项缩小到0项，而排序列表从0项增长到N项。最终版本也是$θ(N log N)$。

**归并排序。** 我们可以通过合并来排序，如之前讲座中讨论的。归并排序是$θ(N log N)$并使用$θ(N)$内存。

**插入排序。** 对于每个项目，将其插入到输出序列的适当位置。朴素解决方案涉及创建一个单独的数据结构。这种算法的内存高效版本通过将项目逐个向左交换，直到它们落在正确的位置。这种插入排序的不变式是，位置i左侧的每个项目都是有序的，而右侧的所有项目尚未被检查。每次交换恰好修复一个逆序对。

**插入排序运行时间。** 在最好情况下，插入排序需要$θ(N)$时间。在最坏情况下，$θ(N^2)$时间。更一般地说，运行时间不会比逆序对的数量更差。
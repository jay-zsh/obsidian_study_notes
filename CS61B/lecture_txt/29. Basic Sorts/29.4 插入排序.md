# 29.4 插入排序

---

## 朴素插入排序

在插入排序中，我们从一个空的输出序列开始。然后，我们从输入中选择一个项目，将其插入到输出数组的正确位置。

朴素地，我们可以通过创建一个完全独立的输出数组，并将输入项放入其中来实现。你可以在这里看到这个算法的演示。

![](PANG/87481b8677dcf3c33a828fec26c7c1aa_MD5.jpg)

使用独立输出数组的朴素插入排序

对于朴素方法，如果输出序列目前包含 kk 个项目，则每次插入需要 O(k)O(k) 时间（在输出数组中移动每个项目）。

---

## 原地插入排序

我们可以通过使用原地交换而非构建独立的输出数组，来改进插入排序的时间和空间复杂度。

你可以在这里看到这个算法的演示。

本质上，我们从左到右遍历数组，每次选择一个项目进行交换。然后，我们将该项目尽可能向前交换到最前端。数组的前端逐渐变得有序，直到整个数组排序完成。

![](PANG/fdede46e32fe9a50d27ad19d2c240281_MD5.jpg)

插入排序算法。紫色项目是正被交换到前端的选定项目，黑色项目是与紫色项目交换的对象。

---

## 插入排序运行时间

插入排序的最佳情况运行时间是 $Θ(N)Θ(N)$——当没有交换发生时，我们只需线性扫描数组。插入排序的最坏情况运行时间是 $Θ(N2)Θ(N2)$——在逆序数组中，我们必须将每个项目一直交换到前端。

---

### 插入排序优势

请注意，在有序或几乎有序的数组上，插入排序的工作量非常少。实际上，它执行的交换次数等于数组中的逆序对数量。

![](PANG/06401ce24a94bb5cc23fb08dccb74ad4_MD5.jpg)

左侧数组仅有 5 个逆序对，右侧数组仅有 3 个。插入排序的工作量极少。

换句话说，在逆序对数量较少的数组上，插入排序可能是最快的排序算法。运行时间为 $Θ(N+K)Θ(N+K)$，其中 $KK$ 是数组中的逆序对数量。如果我们定义几乎有序数组为逆序对数量 $K<cNK<cN$（cc 为常数），则插入排序以线性时间运行。

一个不太明显的经验事实是，插入排序在小型数组（通常大小为 15 或更小）上极快。其分析超出本课程范围，但核心思想是分治算法（如堆排序和归并排序）在“分”阶段花费过多时间，而插入排序立即开始排序。实际上，Java 的归并排序实现在分割小于 15 个项目时使用插入排序。
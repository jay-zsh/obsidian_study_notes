# 29.2 选择排序与堆排序
---

## 选择排序

选择排序算法如下：
1. 查找最小项  
2. 将该元素交换至前端  
3. 重复直至所有元素归位（不存在逆序对）  

该排序算法演示可见[此处](https://docs.google.com/presentation/u/1/d/1p6g3r9BpwTARjUylA0V0yspP2temzHNJEJjCG41I4r0/edit?usp\=sharing)。  

使用数组或类似数据结构时，选择排序时间复杂度为 Θ(N²)。  

您可能已注意到选择排序效率较低——每次需遍历整个剩余数组查找最小值，导致元素被重复检查。  

---
## 堆排序
### 基础堆排序

为避免选择排序的上述缺陷，可采用最大堆替代线性扫描数组。  

*注：基于数组的堆表示法使最大堆能更简洁地维护数组的"有序"与"无序"部分，详见下节。*  

对 N 个元素进行堆排序时：  
1. 将所有元素插入最大堆  
2. 创建输出数组  
3. 反复删除最大堆中的最大元素，将其置于输出数组末端  

#### 基础堆排序分析  
总时间复杂度为 Θ(NlogN)，包含三个主要部分：  
- 插入 N 个元素至堆：O(NlogN)  
- 选择最大元素：Θ(1)  
- 删除最大元素：O(logN)  

较选择排序的 Θ(N²) 有显著提升。  

内存方面，输出数组需额外 Θ(N) 空间。虽劣于选择排序的零额外空间，但运行时优化远胜此缺陷。  

通过堆排序技巧可消除额外输出数组。  

### 原地堆排序  
替代方案是直接利用输入数组构建堆和输出数组。  

采用*自底向上堆化*将输入数组转为堆，而非插入新数组。该过程按逆层级顺序遍历堆，逐步将节点下沉至合适位置。  

此方法无需数据副本。堆化后，沿用基础堆排序思路：弹出最大值置于数组末端。从而维护数组前部（堆结构）为"无序区"，后部（已弹出元素）为"有序区"。  

![](028376526eba004214cc3e7afb012f49_MD5.jpg)  
*自底向上堆化过程*  

算法演示见[此处](https://docs.google.com/presentation/d/1SzcQC48OB9agStD0dFRgccU-tyjD6m3esrSC-GLxmNc/edit?usp\=sharing)。  

#### 原地堆排序时间复杂度  
整体仍为 O(NlogN)：自底向上堆化最多需 N 次下沉操作，每次耗时 O(logN)。  

*注：可证明自底向上堆化时间复杂度为 Θ(N)，但超出课程范围。*  

#### 原地堆排序内存占用  
内存占用降至 Θ(1)。因复用输入数组，无需额外空间（评估内存复杂度时不包含输入空间）。
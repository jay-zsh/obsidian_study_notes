# 12.6 练习题

---

## 事实题

1. 实现`Iterable`接口的类需要哪些方法？
    
2. 关于`java.util.Set`和`java.util.List`接口，以下哪些陈述正确？
    
    - 若向`Set`和`List`添加`String[][]`对象，集合的大小将始终小于或等于列表大小
        
    - `java.util.ArrayList`是`java.util.List`接口的实现类
        
    - `Set`和`List`接口继承自`Iterator`接口
        
    - `Set`和`List`接口继承自`Iterable`接口
        
    
3. 实现`Iterator`的类必须重写哪些方法才能编译通过？

---

### 问题1
实现`Iterable`必须包含`iterator()`方法，该方法返回一个`Iterator`。

---

### 问题2
- **若向`Set`和`List`添加`String[][]`对象，集合的大小将始终小于或等于列表大小**：集合仅存储唯一元素，而列表允许重复元素，因此添加相同元素时列表元素数量始终不少于集合
- **`java.util.ArrayList`是`java.util.List`接口的实现类**：`List`接口的标准实现之一
- **`Set`和`List`接口继承自`Iterable`接口**：`Set`和`List`支持增强型for循环，说明它们实现了`Iterable`

---

### 问题3
`Iterator`必须重写`hasNext()`（返回布尔值指示是否存在更多元素）和`next()`（返回下一个元素）方法。

---

## 概念题

1. 为什么要重写`.equals`方法？

---

### 问题1
从`Object`继承的`.equals()`仅检查内存地址是否相同。对于自定义类，这通常不符合实际需求。

---

## 元认知题

1. 根据课堂所讲的`ArraySetIterator`类，修改构造器使其接收`Comparator<T>`和泛型对象`ref`。新的迭代器应仅返回大于`T`的元素（原始代码如下）：

```java
private class ArraySetIterator implements Iterator<T> {
	private int pos;
	
	public ArraySetIterator() { 
		pos = 0; 
	}
	
	public boolean hasNext() { 
		return pos < size; 
	}
	
	public T next() {
	 	T returnItem = items[pos];
	 	pos += 1;
	 	return returnItem;
	}
}
```

2. 2018春季学期期中考试第7题

---

### 问题1

```java
public class ArraySetGreaterIterator implements Iterator<T> {
    private int pos;
    private T ref;
        
    private Comparator<T> comp;

    public ArraySetGreaterIterator(T ref, Comparator<T> comp) {
        this.ref = ref;
        this.comp = comp;
    }

    @Override
    public boolean hasNext() {
        return pos < size;
    }

    @Override
    public T next() {
        T returnItem = items[pos];
        while (comp.compare(returnItem, ref) <= 0) {
            pos += 1;
            returnItem = items[pos];
        }
        return returnItem;
    }
}
```

---

### 问题2
[参考答案](https://drive.google.com/file/d/1LIyFXwHYCWXNqIgKTsTyKiOYnB79_ykk/view)与[视频解析](https://www.youtube.com/watch?v=nMZn4EV0gGw)可通过课程网站获取。
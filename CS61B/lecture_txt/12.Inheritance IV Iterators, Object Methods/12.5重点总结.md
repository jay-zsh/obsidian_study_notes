# 12.5 本章总结

本章核心要点回顾。

本讲代码可在[此处](https://github.com/Berkeley-CS61B/lectureCode-sp23/tree/main/lec12_inheritance4)获取。

---

### 异常处理

您可能在编码时遇到过诸如`NullPointerException`或`IndexOutOfBoundsException`等异常。现在我们将学习如何主动"抛出"异常。以下是我们抛出异常的示例：

```java
throw new RuntimeException("无明确原因");
```

这能有效确保代码在面临意外行为时仍保持合理运行。

---

### 迭代机制

#### 迭代器与可迭代对象的区别

这两个术语高度相关但存在关键差异。需知它们均为Java接口，但需实现不同方法。以下是简化的迭代器接口定义：

```java
public interface Iterator<T> {
  boolean hasNext();
  T next();
}
```

以下是简化的可迭代对象接口定义：

```java
public interface Iterable<T> {
    Iterator<T> iterator();
}
```

注意：对象（如ArrayList或LinkedList）要成为_可迭代对象_，必须包含返回_迭代器_的方法。迭代器是主动遍历可迭代对象的操作实体。在使用这两个接口时，请牢记这种关联与区别。

---

### 对象方法

#### toString方法

`toString()`方法返回对象的字符串表示形式。例如，`System.out.println(某个对象)`会调用该对象的`toString()`方法，并将其返回的字符串打印至控制台。

这在调试时极为实用，能帮助我们更直观地理解对象的当前状态。

#### == 与 .equals() 的对比

Java中存在两种相等性判断方式："=="和".equals()"方法。核心区别在于：使用"=="时，我们检查两个对象是否具有相同的内存地址（是否指向同一实例）；而.equals()是可被类重写的方法，允许自定义相等性判断逻辑。这使得类能利用自身特性进行更精准的相等性判定。

以判断两个石块是否相等为例：

```java
public class Stone{
  int weight;
  public Stone(int weight){
    this.weight = weight;
  }
}
Stone s = new Stone(100);
Stone r = new Stone(100);
```

若希望重量相同即视为相等，使用"=="判断时这两个石块会被认为不相等（内存地址不同）。但若按如下方式重写equals方法：

```java
public boolean equals(Object o){
  return this.weight \=\= ((Stone) o).weight;
}
```

此时石块将因重量相同而被判定为相等。
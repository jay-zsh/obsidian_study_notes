# 18.1 Rotating Trees

就像摩天轮一样。
 
B树虽然精妙平衡，但实现难度极高。我们需要跟踪多个节点，分裂过程也相当复杂。作为崇尚简洁代码和迎接挑战的计算机科学家，让我们寻找另一种创建平衡树的方法。

---

## 二叉搜索树的多重结构

对于任何二叉搜索树，都存在多种保持其不变量的结构形式。此前我们讨论过**不同插入顺序**会产生不同结构的BST。插入序列会影响树形结构。下图展示了包含元素1、2、3的所有可能BST结构：

![[PANG/065d22664e2875ff38951d44e34615bb_MD5.jpg]]

练习：为每个显示在上方的树，提供一个产生该结构的插入顺序。

---

## 树旋转

旋转的正式定义为：

``` 
rotateLeft(G)：令x为G的右子节点。使G成为x的新左子节点。
```

``` 
rotateRight(G)：令x为G的左子节点。使G成为x的新右子节点。
```

下图展示了节点G进行左旋转的图形化过程：

![[PANG/d0b74856a2fd6cdab8591c690104a5d9_MD5.jpg]]

左旋操作（rotateLeft(G)）的具体过程描述如下：
- G的右子节点P携带其子树与G合并
- P将其左子节点转移给G，随后G下移成为P的左子节点

旋转操作不仅改变树形结构，也会影响树高。我们也可以对非根节点实施旋转：暂时断开该节点与父节点的连接，旋转其子树后重新连接新根节点。

---

### 实现

以下是`rotateRight`和`rotateLeft`的实现代码：

```java
private Node rotateRight(Node h) {
    // 断言 (h != null) && isRed(h.left);
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    return x;
}

// 将右倾链接转换为左倾
private Node rotateLeft(Node h) {
    // 断言 (h != null) && isRed(h.right);
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    return x;
}
```

返回值x将被上层代码用于更新父节点的指针指向。

---

## 通过树旋转平衡二叉搜索树

借助旋转操作，我们可以实际平衡树形结构。观察下例：

![[PANG/ee6bdd76a993bb49bbfa589100227d3b_MD5.jpg]]

对左侧BST进行平衡的操作序列为：
1. `rotateRight(3)`
2. `rotateLeft(1)`

树旋转的核心价值在于：它能在保持搜索树性质的前提下，实现树高的**缩短**或**延长**。

更多示例请参阅[这些幻灯片](https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit#slide=id.g465b5392c_00)中的演示。
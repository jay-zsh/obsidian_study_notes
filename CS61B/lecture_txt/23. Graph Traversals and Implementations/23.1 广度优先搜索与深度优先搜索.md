
# 23.1 广度优先搜索与深度优先搜索

Hug 教授关于图的讲座

在[章节 22.4](https://cs61b-2.gitbook.io/cs61b-textbook/22.-tree-traversals-and-graphs/22.4-graph-problems)中，我们开发了图的深度优先搜索（DFS）遍历。在DFS中，我们在开始查看第二个子节点之前，会先访问第一个子节点的整个谱系——我们实际上是先进行**深度搜索**。

这里我们将讨论广度优先搜索（BFS）（也称为层级顺序遍历）。在BFS中，我们在继续访问任何孙节点之前，会先访问所有直接子节点。换句话说，我们先访问距离源节点1条边的所有节点，然后是距离源节点2条边的所有节点，依此类推。

BFS的伪代码如下：

```
初始化边缘集合 fringe（空队列）
    将起始顶点加入 fringe
    标记起始顶点
    while fringe 非空：
        从 fringe 中移除顶点 v
        for v 的每个邻居 n：
            if n 未被标记：
                将 n 加入 fringe
                标记 n
                设置 edgeTo[n] = v
                设置 distTo[n] = distTo[v] + 1
```

**边缘集合**（fringe）是我们用来存储在遍历发现过程中处于边界的节点的数据结构（即等待检查的下一个节点）。对于BFS，我们使用队列作为边缘集合。

`edgeTo[...]`是一个映射，帮助我们追踪如何到达节点`n`；我们是通过沿着从`v`到`n`的边到达的。

`distTo[...]`是一个映射，帮助我们追踪`n`距离起始顶点的距离。假设每条边的距离值为`1`，那么到`n`的距离就是到达`v`的距离再加1。为什么？因为我们可以使用已知到达`v`的路径，然后通过必然存在于`v`和`n`之间的边（在`for`循环头中，`n`被定义为`v`的邻居，因此该边必然存在）多支付1的距离即可到达`n`。

该幻灯片演示了如何在一个示例图上执行此伪代码。

---

#### 深度优先搜索 vs 广度优先搜索

**问题 18.1**：哪种图遍历算法使用栈而非队列作为其边缘集合？

但需注意，DFS和BFS的区别不仅在于边缘数据结构。它们在标记节点的顺序上也有所不同。对于DFS，我们仅在访问节点（即从边缘集合中弹出节点）时才标记节点。因此，如果某个节点已加入队列但尚未访问，则栈中可能同时存在同一节点的多个实例。而在BFS中，我们一将节点加入边缘集合就立即标记，因此不会出现这种情况。

递归DFS通过递归栈帧自然实现这一点；迭代DFS则手动实现：

```
初始化边缘集合 fringe（空栈）
    将起始顶点压入 fringe
    while fringe 非空：
        从 fringe 弹出一个顶点
        if 顶点未被标记：
            标记该顶点
            访问顶点
            for 顶点的每个邻居：
                if 邻居未被标记：
                    将邻居压入 fringe
```
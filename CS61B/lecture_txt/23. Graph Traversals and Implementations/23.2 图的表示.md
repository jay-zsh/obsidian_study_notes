
# 23.2 图的表示

我们如何在 Java 中创建图？

Hug 教授关于图的讲座

我们将讨论**API 的选择**以及用于表示图的**底层数据结构**。这些决策将深刻影响我们的运行时性能、内存使用以及实现各种图算法的难度。

### 图 API

API（应用程序编程接口）是我们类提供给用户的方法列表，包括方法签名（每个函数接受的参数）及其行为信息。您已见过 Java 开发者为内置类（如 [Deque](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html)）提供的 API。

对于图 API，我们采用通用约定：为每个唯一节点分配整数编号。可通过维护映射表实现，该表记录原始节点标签对应的整数值。这样可避免引入泛型需求，使 API 专门处理整数。

可定义如下 API：

```java
public class Graph {
  public Graph(int V):               // 创建含 V 个顶点的空图
  public void addEdge(int v, int w): // 添加边 v-w
  Iterable<Integer> adj(int v):      // 返回 v 的邻接顶点
  int V():                           // 顶点数量
  int E():                           // 边数量
...
```

客户端（使用图数据结构者）可调用我们提供的任何函数实现算法。所提供的方法将直接影响客户端实现特定算法的难易程度。

---

## 邻接表

在掌握纸上绘图和基础概念后，现需考虑计算机内部如何表示图。我们希望快速获取以下信息：
- 顶点 `u` 和 `v` 是否邻接？
- 边 `e` 是否与顶点 `v` 关联？
- `v` 的邻接顶点有哪些？
- 与 `v` 关联的边有哪些？

假设需表示下图：
![[PANG/caccf7fe0aa11c444f2394db2f4d4f62_MD5.jpg]]

可用_邻接表数组_实现。该结构中，数组大小等于图的顶点数，每个位置对应一个顶点，并指向链表（邻接表），链表中元素表示该顶点的邻居。

上图对应的邻接表数组如下：
![[PANG/268edba3dc4ca1f6f4fd4851540adb57_MD5.jpg]]

---

## 邻接矩阵

另一种表示图中边的数据结构是_邻接矩阵_。该结构使用大小为 N×N（N 为顶点数）的二维布尔数组，矩阵中 (i, j) 项为 true 表示存在从 i 到 j 的边，false 表示无边。因此，每个顶点在矩阵中拥有行和列，表格值指示边是否存在。

上图对应的邻接矩阵如下：
![[PANG/6c377c3dcda857041d13338a4b0c7def_MD5.jpg]]

---

## 效率

底层数据结构的选择将影响图的运行时和内存使用。[幻灯片](https://docs.google.com/presentation/d/11iacyiFt3QUrzo1yAU_xoXAjGTH4UzV7o6CR04HYRrI/edit#slide=id.g54593997ea_0_422)中的表格总结了不同操作在各表示法下的效率。强烈建议勿直接抄录至考试备忘单，而应先理解这些界限的根本来源。讲座详细解释了多数单元格背后的原理。

需注意：基于邻接表的图运行 DFS/BFS 时间复杂度为 O(V+E)，而基于邻接矩阵的图为 O(V²)。理解原因请参阅[幻灯片](https://docs.google.com/presentation/d/11iacyiFt3QUrzo1yAU_xoXAjGTH4UzV7o6CR04HYRrI/)。
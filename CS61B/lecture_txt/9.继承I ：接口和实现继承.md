
--- 

## 继承核心概念

### 方法重载问题

```java
// 不同列表类型的重复方法
public static String longest(SLList<String> list) { /*...*/ }
public static String longest(AList<String> list) { /*...*/ }
```

|重载缺点|解决方案|
|---|---|
|代码重复|接口继承|
|维护成本高|统一接口规范|
|扩展性差|多态实现|

### 上位词(Hypernym)与下位词(Hyponym)

```java
// 接口定义（上位词）
public interface List61B<Item> {
    void addFirst(Item x);
    Item get(int i);
    int size();
    // ...其他方法声明
}

// 实现接口（下位词）
public class AList<Item> implements List61B<Item> {
    // 必须实现接口所有方法
}

public class SLList<Item> implements List61B<Item> {
    // 必须实现接口所有方法
}
```

## 接口继承关键实现

### 方法重写规范

```java
@Override  // 编译器校验注解
public void addFirst(Item x) {
    insert(x, 0);  // 自定义实现
}
```

|注解作用|未使用@Overrride风险|
|---|---|
|编译器校验方法签名|拼写错误导致意外重载|
|明确设计意图|难以追踪继承关系|

### 动态方法选择

```java
List61B<String> list = new SLList<>();  // 静态类型 vs 动态类型
list.addFirst("data");  // 实际调用SLList的实现
```

**类型对比表**  

| 类型   | 特点     | 示例                       |     |
| ---- | ------ | ------------------------ | --- |
| 静态类型 | 声明时的类型 |  `List61B<String> list`  |     |
| 动态类型 | 实际对象类型 |  `new SLList<>()`        |     |

## 实现继承与默认方法

### 接口默认方法

```java
public interface List61B<Item> {
    default void print() {  // 默认实现
        for (int i=0; i<size(); i++) 
            System.out.print(get(i) + " ");
        System.out.println();
    }
}

// 子类可选择性重写
public class SLList<Item> implements List61B<Item> {
    @Override
    public void print() {  // 优化实现
        Node p = sentinel.next;
        while (p != null) {
            System.out.print(p.item + " ");
            p = p.next;
        }
    }
}
```

## 继承类型对比

|特性|接口继承|实现继承|
|---|---|---|
|继承内容|方法签名|具体实现|
|实现要求|必须实现所有接口方法|可继承父类实现|
|多继承支持|✅ 可多接口继承|❌ 单继承|
|默认方法|Java 8+ 支持默认方法|通过super调用父类实现|
|设计原则|定义"能做什么"|定义"如何做"|

## 继承设计原则

1. **Liskov替换原则**  
    子类必须能替换父类（`is-a`关系）
    
2. **避免深度继承**  
    建议不超过3层继承层次
    
3. **组合优于继承**  
    优先使用组合关系而非继承
    

```java
// 错误示例（has-a关系）
public class Claw {} 
public class Cat extends Claw {}  // 错误！Cat has-a Claw

// 正确设计
public class Cat {
    private Claw claw;  // 组合关系
}
```

## 继承实践案例

### 多态应用

```java
public class WordUtils {
    public static String longest(List61B<String> list) {
        String max = list.get(0);
        for (int i=1; i<list.size(); i++) {
            String current = list.get(i);
            if (current.length() > max.length()) {
                max = current;
            }
        }
        return max;
    }
}

// 使用示例
List61B<String> alist = new AList<>();
List61B<String> slist = new SLList<>();
WordUtils.longest(alist);  // 统一处理不同列表类型
WordUtils.longest(slist);
```

## 继承常见问题

### 方法冲突解决

```java
interface A { default void foo() { System.out.println("A"); } }
interface B { default void foo() { System.out.println("B"); } }

class C implements A, B {  // 编译错误
    // 必须显式重写解决冲突
    @Override
    public void foo() {
        A.super.foo();  // 明确指定接口实现
    }
}
```

### 继承vs组合对比表

|标准|继承|组合|
|---|---|---|
|关系类型|is-a|has-a|
|耦合度|高|低|
|灵活性|低（编译时绑定）|高（运行时绑定）|
|代码复用|父类实现|委托调用|
|多态支持|原生支持|需接口实现|
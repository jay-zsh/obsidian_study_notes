# 19.2 哈希码

哈希机制的核心！

我们面临的问题是：并非每个Java对象都能轻松转换为数字。然而，哈希背后的核心思想是将任何对象转换为数字表征。关键在于通过哈希函数将键转换为不同数值，并将该数值转换为数组索引来进行访问。

我们通过自定义`hashCode()`函数实现这一目标，该函数返回`int`类型的_哈希值_。例如，Java内置的String类可能包含以下代码块：

```java
public class String {
    public int hashCode() {
        //具体实现
    }
}
```

基于此示例，我们可以调用`key.hashCode()`为String实例`key`生成整数哈希码。

---

# Hug教授的哈希码讲座

## 内存低效性问题

前文提到的内存低效问题在于：对于小范围的哈希值，我们可以使用为每个哈希值单独分配空间的数组。这种方式在索引值较小且接近零时效果良好。但请注意Java的32位整型支持从-2,147,483,648到2,147,483,647的数值范围。即使仅支持特殊字符，我们的数组也需要长达1,112,064个元素！

解决方案是调整索引策略。假设我们只需要支持长度为10的数组以避免内存浪费，如何将可能高达数百万或数十亿的数值转换为0到9之间的值？

---

### 取模运算

通过**取模运算符（%）**实现这一转换：

_复习_：模运算结果类似于除法余数。例如`65 % 10`返回`5`，`3 % 10 = 3`，`20 % 10 = 0`，`19 % 10 = 9`。这与项目1中避免数组越界的循环队列实现原理相同。

通用解决方案公式：

```java
Math.floorMod(key.hashCode(), array.length)
```

其中`array`代表哈希表的底层数组。

_注意_：Java的`Math.floorMod`能正确处理负数取模，而`%`运算符不能。
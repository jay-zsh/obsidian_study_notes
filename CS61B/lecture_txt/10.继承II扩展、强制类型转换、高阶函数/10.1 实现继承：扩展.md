## 继承关键语法

### `implements` vs `extends`

|关键字|应用场景|功能特性|
|---|---|---|
|`implements`|类实现接口时使用|强制实现接口定义的所有方法|
|`extends`|类继承另一个类时使用|自动继承父类非私有属性和方法|

```java
// 接口继承示例
public class SLList<T> implements List61B<T> { ... }

// 类继承示例
public class RotatingSLList<T> extends SLList<T> { ... }
```

## 继承扩展实践

### 旋转链表实现

```java
public class RotatingSLList<T> extends SLList<T> {
    /** 将最后一个元素移动到链表头部 */
    public void rotateRight() {
        T last = removeLast();  // 调用父类方法
        addFirst(last);
    }
}
```

**执行示例**

```java
RotatingSLList<Integer> list = new RotatingSLList<>();
list.addLast(10); list.addLast(11); list.addLast(12); list.addLast(13);
list.rotateRight();
// 原始链表: [10, 11, 12, 13] → 旋转后: [13, 10, 11, 12]
```

### 记忆删除元素的链表

```java
public class VengefulSLList<T> extends SLList<T> {
    private SLList<T> lostItems;  // 记录被删除元素

    public VengefulSLList() {
        super();        // 显式调用父类无参构造（可省略）
        lostItems = new SLList<>();
    }

    @Override
    public T removeLast() {
        T item = super.removeLast();  // 调用父类方法
        lostItems.addLast(item);      // 记录被删元素
        return item;
    }

    public void printLostItems() {
        lostItems.print();
    }
}
```

**方法调用对比**  
| 方法调用 | 执行结果 |  
|------------------|----------------------------------|  
| `super.removeLast()` | 调用父类原始删除逻辑 |  
| `this.removeLast()` | 递归调用当前类重写后的删除方法 |

## 构造函数机制

### `super` 关键字使用规则

1. **隐式调用**  
    子类构造函数未显式调用`super`时，Java自动调用父类**无参构造**
2. **显式调用**  
    父类没有无参构造时，必须显式调用指定构造

```java
public class CustomSLList<T> extends SLList<T> {
    public CustomSLList(T x) {
        super(x);  // 必须显式调用父类带参构造
    }
}
```

**构造函数对比示例**

```java
// 合法构造（隐式调用super()）
public VengefulSLList() {
    lostItems = new SLList<>();
}

// 等效显式写法
public VengefulSLList() {
    super();
    lostItems = new SLList<>();
}

// 非法构造（父类无无参构造时）
public VengefulSLList(T x) {
    // 未显式调用super(x) → 编译错误
    lostItems = new SLList<>();
}
```

## 继承关系设计原则

### Is-a 与 Has-a 对比

|关系类型|描述|适用场景|实现方式|
|---|---|---|---|
|Is-a|严格的"是一个"关系|子类是父类的特殊化|`extends`|
|Has-a|"包含一个"的组成关系|需要复用功能但非继承|组合（成员变量）|

**错误示范**

```java
// ❌ 错误：用继承实现has-a关系
public class Cat extends Claw { ... }

// ✅ 正确：用组合实现has-a
public class Cat {
    private Claw claw;
}
```

## Java继承体系

### Object类地位

所有Java类默认继承`Object`类，形成三层结构：

```
Object → SLList → VengefulSLList
```

**Object关键方法**  

| 方法 | 作用 |  
|---------------------|-------------------------|  
| `equals(Object obj)` | 对象相等性判断 |  
| `hashCode()` | 返回对象哈希码 |  
| `toString()` | 返回对象字符串表示形式 |

```java
// 重写toString示例
@Override
public String toString() {
    return "VengefulSLList with lost items: " + lostItems;
}
```

## 继承设计建议

1. **控制继承深度**  
    建议不超过3层继承层次，避免过度复杂
    
2. **优先使用组合**  
    非严格is-a关系时，用组合替代继承
    
3. **慎用方法重写**  
    重写方法需遵循Liskov替换原则，保持行为一致性
    
4. **抽象类应用**  
    包含通用实现但不应被实例化的类应声明为`abstract`
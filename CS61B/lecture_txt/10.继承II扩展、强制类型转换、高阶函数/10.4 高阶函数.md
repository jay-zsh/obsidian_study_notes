## 高阶函数核心概念

> 高阶函数（Higher-Order Function）是指以函数作为参数或返回值的函数

### Python示例（直接传递函数）

```python
def tenX(x):
    return 10 * x

def do_twice(f, x):
    return f(f(x))  # 函数作为参数传递

print(do_twice(tenX, 2))  # 输出 200
```

### Java 7实现方案（使用接口模拟）
- IntUnaryFunction 接口
```java
// 1. 定义函数接口
public interface IntUnaryFunction {
    int apply(int x);
}

```

- Tenx 工具函数
```java
// 2. 实现具体函数
public class TenX implements IntUnaryFunction {
    @Override
    public int apply(int x) {
        return 10 * x;
    }
}

```

- HoFDemo 
```java

// 3. 高阶函数应用
public class HoFDemo {
    public static int doTwice(IntUnaryFunction f, int x) {
        return f.apply(f.apply(x));  // 通过接口调用
    }

    public static void main(String[] args) {
        System.out.println(doTwice(new TenX(), 2));  // 输出 200
    }
}
```

## 实现原理对比

|特性|Python实现|Java 7实现|
|---|---|---|
|函数传递方式|直接传递函数对象|通过接口实例传递|
|语法复杂度|简洁（首类函数支持）|冗余（需定义接口和实现类）|
|类型安全|动态类型|静态类型检查|
|扩展性|灵活（任意可调用对象）|需预先定义接口|
|执行效率|解释执行较慢|JIT编译优化较快|
|代码示例|`do_twice(tenX, 2)`|`doTwice(new TenX(), 2)`|

## 关键实现解析

### 接口设计要点

```java
public interface IntUnaryFunction {
    int apply(int x);  // 单方法接口模拟函数式编程
}
```

- **单一方法原则**：接口只定义一个抽象方法（函数式接口）
- **类型约束**：明确输入输出类型，保证类型安全
- **实现绑定**：通过类实现接口来绑定具体操作

### 高阶函数调用流程

1. **创建函数对象**：`new TenX()`
2. **传递接口实例**：作为参数传递给`doTwice`方法
3. **多次应用函数**：通过`apply`方法链式调用
4. **返回最终结果**：`f(f(x))`的计算结果

## 扩展应用场景

### 通用函数接口设计
- interface接口
```java
// 二元操作接口
public interface IntBinaryFunction {
    int apply(int a, int b);
}

```
- Add function
```java
// 实现加法操作
public class Add implements IntBinaryFunction {
    @Override
    public int apply(int a, int b) {
        return a + b;
    }
}


```

- Multiply function
```java
// 实现乘法操作
public class Multiply implements IntBinaryFunction {
    @Override
    public int apply(int a, int b) {
        return a * b;
    }
}
```

### 函数组合器

```java
public class FunctionComposer {
    public static IntUnaryFunction compose(IntUnaryFunction f, IntUnaryFunction g) {
        return new IntUnaryFunction() {
            @Override
            public int apply(int x) {
                return f.apply(g.apply(x));  // f(g(x))
            }
        };
    }
}
```

## Java演进对比

|版本|特性|示例代码|
|---|---|---|
|Java 7|接口+匿名类|`new IntUnaryFunction(){...}`|
|Java 8|Lambda表达式|`x -> 10 * x`|
|Java 8|方法引用|`ClassName::methodName`|
|Java 8|内置函数式接口|`Function<T,R>`, `Consumer<T>`|

> 虽然Java 8+提供了更简洁的语法，但理解接口实现方式仍是掌握高阶函数的基础
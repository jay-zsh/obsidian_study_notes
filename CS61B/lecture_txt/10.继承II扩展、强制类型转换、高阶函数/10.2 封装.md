
---

> 在构建大型项目时，复杂性的管理是核心挑战

### 复杂性管理工具

|工具|作用描述|示例场景|
|---|---|---|
|分层抽象|将系统分解为不同层级，每层关注特定功能细节|网络协议栈（OSI模型）|
|抽象障碍|定义清晰的接口边界，隐藏实现细节|使用接口定义数据库操作规范|
|对象自治|让对象自主决定方法执行逻辑|`list.add()`内部自动扩容|
|信息隐藏|限制对非必要细节的访问|私有变量+公有访问方法|

## 封装的核心概念

### 模块化设计原则

**模块定义**：协同工作的方法集合，完成特定任务组  
**封装三要素**：

1. 私有属性（Private Properties）
2. 公有方法（Public Methods）
3. 严格的访问控制（Access Control）

### 封装实现示例

```java
public class BankAccount {
    // 私有属性（信息隐藏）
    private double balance;  
    private String accountNumber;

    // 公有方法（受控访问）
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    public double getBalance() {
        return balance;
    }

    // 私有方法（内部实现细节）
    private void logTransaction(String type) {
        System.out.println("Account " + accountNumber 
            + " " + type + ": " + balance);
    }
}
```

## 访问控制修饰符

|修饰符|类内访问|包内访问|子类访问|全局访问|典型应用场景|
|---|---|---|---|---|---|
|`private`|✅|❌|❌|❌|敏感数据/内部实现细节|
|`protected`|✅|✅|✅|❌|继承体系中的共享方法|
|`public`|✅|✅|✅|✅|公共服务API接口|
|默认(package-private)|✅|✅|❌|❌|模块内部组件通信|

## 封装的优势

1. **实现隔离**：修改内部实现不影响外部调用
2. **数据校验**：通过方法控制数据合法性
    
    ```java
    public void setAge(int age) {
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException();
        }
        this.age = age;
    }
    ```
    
3. **状态一致性**：保证对象始终处于有效状态
4. **降低耦合度**：模块间通过接口交互

## 实际应用案例

### 集合类封装

```java
public class IntArray {
    private int[] data;
    private int size;

    // 隐藏扩容细节
    public void add(int item) {
        if (size == data.length) {
            resize(data.length * 2);
        }
        data[size++] = item;
    }

    private void resize(int capacity) {
        int[] newData = new int[capacity];
        System.arraycopy(data, 0, newData, 0, size);
        data = newData;
    }
}
```

> 通过封装实现的抽象障碍：使用者只需调用`add()`方法，无需关心底层数组如何扩容
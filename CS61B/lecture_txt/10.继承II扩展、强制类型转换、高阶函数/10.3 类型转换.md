
---

### 静态类型 vs 动态类型

|类型特性|静态类型（编译时类型）|动态类型（运行时类型）|
|---|---|---|
|定义时机|变量声明时指定|对象实例化时确定|
|检查阶段|编译期校验|运行期验证|
|示例代码|`Dog myDog = new Poodle();`|`Poodle p = (Poodle) myDog;`|
|类型约束|决定可调用方法范围|决定实际执行方法版本|
|修改可能性|不可变（由声明决定）|随对象创建固定|

---

## 转型操作类型

### 1. 向上转型（Upcasting）

```java
Poodle curls = new Poodle("Curls", 3);
Dog genericDog = curls;  // 自动转型，无需显式转换
```

**特点**：

- 安全：子类对象可视为父类实例
- 隐式完成，编译器自动处理
- 丢失子类特有方法访问权
---

### 2. 向下转型（Downcasting）

```java
Dog unknown = getAnimal();
if (unknown instanceof Poodle) {
    Poodle specific = (Poodle) unknown;  // 显式强制转换
    specific.showRibbon();
}
```

**特点**：

- 潜在风险：可能导致`ClassCastException`
- 必须显式使用强制类型转换符`(Type)`
- 转换前需用`instanceof`进行类型检查

---

## 安全强制转换操作流程

```java
// 1. 定义继承体系
class Animal {}
class Cat extends Animal {
    void purr() { System.out.println("Purr~"); }
}

// 2. 获取不确定类型对象
Animal mysteryAnimal = getRandomAnimal();

// 3. 安全转换步骤
if (mysteryAnimal instanceof Cat) {    // 类型检查
    Cat realCat = (Cat) mysteryAnimal;  // 强制转换
    realCat.purr();                     // 访问子类方法
} else {
    System.out.println("Not a cat!");
}

// 辅助方法（模拟随机返回动物）
private static Animal getRandomAnimal() {
    return Math.random() > 0.5 ? new Cat() : new Animal();
}
```

---

## 转型操作对比

|转型方向|向上转型|向下转型|
|---|---|---|
|语法形式|自动隐式转换|显式强制转换|
|类型安全|100%安全|需前置类型检查|
|数据精度|可能丢失子类特性|恢复子类完整功能|
|典型应用场景|多态方法参数|还原具体子类实例|
|错误处理|无需处理|需try-catch或instanceof校验|

---

## 关键注意事项

1. **避免盲目转型**
    
    ```java
    Dog d = new Dog();
    Poodle p = (Poodle) d;  // 运行时抛出ClassCastException
    ```
    
2. **instanceof的正确使用**
    
    - 检查null安全：`null instanceof Type` 始终返回false
    - 继承链校验：`cat instanceof Animal` 返回true
3. **泛型容器转型限制**
    
    ```java
    List<Animal> animals = new ArrayList<>();
    List<Dog> dogs = (List<Dog>) animals;  // 编译错误，泛型擦除后类型不兼容
    ```
    
4. **数组类型转换规则**
    
    ```java
    Dog[] dogArray = new Poodle[10];      // 合法向上转型
    dogArray[0] = new Dog();              // 运行时抛出ArrayStoreException
    ```
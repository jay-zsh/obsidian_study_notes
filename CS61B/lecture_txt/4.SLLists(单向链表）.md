
---

> 对IntList裸递归结构的渐进式改进记录

## 改进1：重命名与结构简化

原始`IntList`结构：

```java
public class IntList {
    public int first;
    public IntList rest;
    // 构造器与辅助方法省略
```

优化后重命名为`IntNode`：

```java
public class IntNode {
    public int item;  // 原first改为item
    public IntNode next;  // 原rest改为next
    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

---

## 改进2：封装交互层

创建中间类`SLList`作为用户接口：

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }
}
```

|操作对比|IntList实现|SLList实现|
|---|---|---|
|创建单元素链表|`IntList L1 = new IntList(5, null)`|`SLList L2 = new SLList(5)`|
|添加首元素|`L = new IntList(10, L)`|`L.addFirst(10)`|

![IntList_vs_SLList](https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/IntList_vs_SLList.png)


---

## 改进3：访问控制

通过`private`保护数据结构：

```java
public class SLList {
    private IntNode first;  // 限制直接访问
    // 构造器与方法保持不变
```

非法访问示例（编译报错）：

```java
SLList L = new SLList(15);
L.first.next.next = L.first.next;  // 错误: first是private
```

---

## 改进4：嵌套类优化

将`IntNode`作为静态内部类：

```java
public class SLList {
    private static class IntNode {  // 静态嵌套类
        public int item;
        public IntNode next;
        // 构造器
    }
    private IntNode first;
    // 类方法
```

---

## 改进5：大小缓存

添加size缓存机制：

```java
public class SLList {
    private int size;  // 新增大小缓存
    
    public SLList(int x) {
        first = new IntNode(x, null);
        size = 1;  // 初始化时记录
    }
    
    public void addFirst(int x) {
        first = new IntNode(x, first);
        size += 1;  // 更新缓存
    }
```

---

## 改进6：空列表处理

### 6a 哨兵节点方案

```java
public class SLList {
    private IntNode sentinel;  // 永久存在的哨兵节点
    
    public SLList() {
        sentinel = new IntNode(63, null);  // 任意值
        size = 0;
    }
```

![哨兵节点结构](https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/empty_sentinelized_SLList.png)



### 6b 改进的addLast方法

```java
public void addLast(int x) {
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }
    p.next = new IntNode(x, null);
    size++;
}
```


---

## 关键不变量

1. 哨兵节点始终存在
2. 首元素位置：`sentinel.next.item`
3. size变量始终反映真实节点数


---

## 方法对比表

|方法|时间复杂度|实现要点|
|---|---|---|
|addFirst()|O(1)|直接修改哨兵节点的next|
|addLast()|O(N)|需要遍历到链表末端|
|size()|O(1)|通过size缓存直接返回|
|getFirst()|O(1)|访问sentinel.next.item|

![三元素哨兵链表](https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/three_item_sentenlized_SLList.png)

> 关键设计思想：通过封装和哨兵节点消除边界条件，使链表操作逻辑统一化。private访问控制与静态嵌套类的使用有效降低了代码耦合度。
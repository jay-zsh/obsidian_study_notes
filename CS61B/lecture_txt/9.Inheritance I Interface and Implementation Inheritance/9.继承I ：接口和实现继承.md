# 9. 继承 I：接口继承与实现继承

---

### 问题根源

回顾我们上周创建的两个列表类：SLList 和 AList。观察它们的文档说明，会发现它们的结构高度相似。事实上，它们的支持方法完全一致！

假设我们需要编写一个 `WordUtils` 类，其中包含可操作词表的方法，包括计算 SLList 中最长字符串的方法。

**练习 4.1.1** 请尝试自行编写此方法。该方法应接收一个字符串类型的 SLList 并返回列表中最长的字符串。

以下是我们的实现方案：

```java
public static String longest(SLList<String> list) {
    int maxDex = 0;
    for (int i = 0; i < list.size(); i += 1) {
        String longestString = list.get(maxDex);
        String thisString = list.get(i);
        if (thisString.length() > longestString.length()) {
            maxDex = i;
        }
    }
    return list.get(maxDex);
}
```

如何使此方法也适用于 AList？

只需修改方法签名中的参数类型：

```java
SLList<String> list
```

改为：

```java
AList<String> list
```

现在我们的 `WordUtils` 类中存在两个完全同名的方法：

```java
public static String longest(SLList<String> list)
```

和

```java
public static String longest(AList<String> list)
```

这在 Java 中是允许的！这种特性称为 _方法重载_。当调用 WordUtils.longest 时，Java 会根据参数类型自动选择对应的方法。传入 AList 则调用 AList 版本，传入 SLList 同理。

虽然 Java 的智能处理机制值得肯定，但重载存在以下缺陷：

- 代码重复严重，导致可读性降低
- 维护成本增加，任何方法修改都需要在所有重载版本中同步更新
- 新增列表类型时需要为每个类复制方法

---

### 上位词、下位词与接口继承

在语言学与现实世界中，词汇与对象之间存在逻辑层级关系。

"犬类"是"贵宾犬"、"阿拉斯加犬"、"哈士奇"等概念的 _上位词_，而后者则是前者的 _下位词_。这种关系形成"is-a"的层级链：

- 贵宾犬 "is-a" 犬类
- 犬类 "is-a" 食肉目
- 食肉目 "is-an" 动物

![[fd7757240bec370c9350b50914f61273_MD5.jpg]]

SLList 和 AList 也存在类似关系！两者都是更广义列表概念的下位词。

我们将通过 Java 形式化这种关系：若 SLList 是 List61B 的下位词，则 SLList 是 List61B 的 **子类**，而 List61B 是 SLList 的 **超类**。

**图 4.1.1** ![[e80f6d1d586dfdf9372673a7a7080c1a_MD5.jpg]]

在 Java 中建立这种层级关系需要 **两个步骤**：

1. 为广义列表定义超类类型（我们命名为 List61B）
2. 声明 SLList 和 AList 为该类型的下位词

List61B 是 Java 中的 **接口**，本质上是一份行为契约，仅规定列表必须具备的功能，不提供具体实现。以下是 List61B 接口：

```java
public interface List61B<Item> {
    public void addFirst(Item x);
    public void addLast(Item y);
    public Item getFirst();
    public Item getLast();
    public Item removeLast();
    public Item get(int i);
    public void insert(Item x, int position);
    public int size();
}
```

通过 `implements` 关键字建立子类关系：

```java
public class AList<Item> implements List61B<Item> {...}
```

`implements List61B<Item>` 表示 AList 承诺实现 List61B 接口定义的所有方法。现在我们可以将 `WordUtils` 中的 `longest` 方法参数改为 List61B 类型，因为 AList 和 SLList 都满足"is-a"关系。

---

### 方法重写

我们需要在子类中实现 List61B 规定的方法。建议（在 61B 课程中强制要求）在重写方法时添加 `@Override` 注解：

```java
@Override
public void addFirst(Item x) {
    insert(x, 0);
}
```

即使省略该注解，重写仍然生效。但添加注解有以下优势：

- 作为编程安全机制，编译器会校验方法签名
- 防止拼写错误导致的方法定义错误（如将 `addLast` 误写为 `addLsat`）

---

### 接口继承

接口继承指子类继承超类的所有方法/行为规范。如 List61B 接口仅定义方法签名，具体实现由子类完成。这种继承具有多代传递性（如图 4.1.1），AList 不仅继承 List61B 的方法，还继承其所有祖先类的方法直至最高层超类。

---

### 黄金赋值法则（GRoE）

回顾第一章介绍的黄金赋值法则：赋值语句 `a = b` 要求 b 的类型必须与 a 兼容。现在分析以下代码：

```java
public static void main(String[] args) {
    List61B<String> someList = new SLList<String>();
    someList.addFirst("elk");
}
```

**练习 4.1.2** 此代码能否编译？运行时会发生什么？

正确答案：
代码能够编译运行。创建 SLList 实例并将其地址存入 someList 变量后，通过 someList.addFirst() 成功将 "elk" 插入 SLList。

---

### 实现继承

我们可以在 List61B 中编写已实现的方法（使用 `default` 关键字）：

```java
default public void print() {
    for (int i = 0; i < size(); i += 1) {
        System.out.print(get(i) + " ");
    }
    System.out.println();
}
```

所有实现 List61B 的类都可使用此方法。但需注意：对于 SLList，这种遍历方式效率较低，应重写方法：

```java
@Override
public void print() {
    for (Node p = sentinel.next; p != null; p = p.next) {
        System.out.print(p.item + " ");
    }
}
```

Java 通过 **动态方法选择** 机制决定调用哪个版本的方法。变量的类型分为：

- 静态类型：声明时的类型（如 `List61B<String> lst`）
- 动态类型：实际对象类型（如 `new SLList<String>()`）

当调用重写方法时，Java 根据对象的动态类型选择对应实现。

**重要提示**：此机制不适用于重载方法！重载方法的选择依据参数静态类型。

---

### 接口继承 vs 实现继承

关键区别：

- 接口继承（What）：规定子类应具备的能力
  - 例：所有列表都应支持打印功能，具体实现方式不限
  
- 实现继承（How）：规定子类的具体行为方式
  - 例：列表必须通过顺序获取元素实现打印

建立类层级关系时，必须确保子类与超类存在"is-a"关系（如 Cat is-an Animal），而非"has-a"关系（如 Cat has-a Claw）。实现继承存在以下缺陷：

- 开发人员可能遗忘已重写的方法
- 多个接口的默认方法可能产生冲突
- 可能导致代码过度复杂化
# 31.3 模块化设计
---
一种管理复杂性的工具。

模块化设计是管理复杂性的强大工具，因为它将项目复杂性划分为可管理的部分。实现模块化设计的一种方法是创建辅助方法或接口。这样，程序员可以独立处理每个复杂性组件，而无需始终跟踪他们编写的每段代码的细节。

---
### 模块应保持简单
---
在理想情况下，每个模块彼此完全独立。遗憾的是，这无法实现，因为每个模块的代码需要调用其他模块。然而，我们仍可努力最小化模块间的依赖！换言之，我们希望最小化使用给定模块时需要了解的细节数量。这正是我们讨论实现与接口区别时的核心含义。优秀的模块不应要求用户了解具体实现才能使用它；仅了解模块接口就应足够。更改模块的实现不应影响其接口。

约翰·奥斯特豪特曾说："最佳模块的接口远比其实现简单。"这是一条值得恪守的准则，付诸实践将避免诸多困扰。

另一项最小化复杂性的技术是限制用户操作范围。如果用户无需与实例变量交互，则不应授予其访问权限。

---
### 接口规则
---
接口有进一步规则，分为正式规则和非正式规则。两者的区别在于非正式规则不由编译器强制执行。

正式规则是方法签名的列表。如果接口实现类中未实现某方法，编译器将报错。

非正式规则的示例如下：
- 迭代器类不自行调用 hasNext()（因特定原因），而要求用户调用。
- 抛出的任何异常。
- 任何运行时规范。

需特别警惕非正式规则！它们难以追踪。

---
### 模块应具备深度
---
另一精妙理念是模块应具备深度：接口简洁但功能强大。我们常如此实践，正如61B课程所示！例如，集合是一个深度模块，拥有强大功能和简单接口。红黑树便是极深模块——我可执行添加、包含和删除操作，且无需了解任何非正式细节，一切均在底层封装。强大功能意味着所有操作均高效。树平衡通过复杂而精妙的规则维护，这些规则棘手但被隐藏于表层之下。保持模块深度的最关键方法是践行信息隐藏。

---
### 信息隐藏
---
即尽可能将变量设为私有，不让任何人窥探模块内部。将所有巧妙设计嵌入模块中。这将保持接口简洁，并便于系统修改。若存在错误，我可直接修复而无需考虑其他上下文。信息隐藏的对立面是信息泄露。

---
### 信息泄露
---
当设计决策反映在多个模块中时即发生信息泄露。
- 对任一模块的更改需同步修改所有模块。
- 信息泄露是软件设计中最关键的红旗警示之一。
- 作为软件设计师，你能培养的最佳技能之一是对信息泄露的高度敏感性。

---
### 时间分解
---
信息泄露的最大诱因之一是"时间分解"，尤其在BYOW（自建世界）中。系统结构强烈反映事件发生的顺序。

例如，学生在BYOW中常执行以下操作：
- 游戏以输入字符串启动，故调用 interactWithInputString()
    - 解析字符串并通过提取 N#####S 找到种子（包含种子的示例代码）。
    - 生成世界。
    - 使用 move(World, char) 处理每个字符。
    - 等等。
- 游戏无输入字符串启动，故调用 interactWithKeyboard
    - 显示菜单并收集种子（用于生成世界的数字）。
    - 生成世界。
    - 循环调用 moveWithKeyboard(World) 直至完成。
    - 等等。

因项目开发的时间讨论与事件发生的时间分解，你未能识别它们应共享收集和提取种子的代码。

---
### 总结
---
- 构建在代码多处所需功能的类。
- 创建深度模块：接口简单但处理复杂任务的类。
- 避免过度依赖时间分解（即分解主要由事件发生顺序驱动）。
    - 少量时间分解可接受，但需修复由此引发的信息泄露！
- 保持战略性，而非战术性。
- 最关键的是：在无需时对自身隐藏信息！
# 14.3 快速合并

Hug教授对快速合并算法的阐释

假设我们优先优化`connect`操作的速度。我们仍使用数组表示集合，但不再记录组别ID，而是让每个元素存储其父节点的索引值。若元素没有父节点（即根节点），则用负值表示。

这种表示方式让我们可以将每个集合想象成树结构。例如，集合`{0, 1, 2, 4}、{3, 5}、{6}`可表示为：

需注意我们仅用单个数组即可表示整个树结构，树状可视化只是辅助理解。

![[PANG/96ce787b31adff5ff3ddfffd88bf9f8a_MD5.jpg]]

快速合并算法定义辅助函数`find(int item)`，该函数返回元素所在树的根节点。例如上例中，`find(4) == 0`，`find(1) == 0`，`find(5) == 3`等。每个元素都有唯一的根节点。

**`connect(x, y)`操作**

连接两个元素时，我们先找到各自的根节点，然后将其中一个根节点设置为另一个的子节点。操作示例：

`connect(5, 2)`：
1. `find(5)` -> 3    
2. `find(2)` -> 0    
3. 将`find(5)`的父节点设为`find(2)`，即`parent[3] = 0`

此时元素3指向元素0，两棵树合并为一棵。

![[PANG/3a04693c27bb406aad17d89d91ae89a0_MD5.jpg]]

最优情况下，若x和y都是根节点，`connect(x, y)`只需让x指向y，时间复杂度为Θ(1)（故得名快速合并）

**`isConnected(x, y)`操作**

若两个元素属于同一集合，则必然具有相同根节点。因此只需检查`find(x) == find(y)`即可判断连通性。

---

## 性能分析

快速合并存在潜在性能问题：树可能退化为链式结构。此时查找根节点操作`find(item)`将变得昂贵。考虑以下退化树：

![[PANG/89f94a37ef6c330601df8de8bc3b86a0_MD5.jpg]]

最坏情况下需要遍历所有元素才能找到根节点，时间复杂度为Θ(N)。由于`connect`和`isConnected`都需要调用`find`，这两个操作的时间复杂度上界均为O(N)。

---

## 总结与代码实现

N = 并查集数据结构中的元素数量

实现方式 | 构造函数 | connect操作 | isConnected操作
--- | --- | --- | ---
快速合并 | Θ(N) | O(N) | O(N)
快速查找 | Θ(N) | Θ(N) | Θ(1)

虽然时间复杂度表显示快速合并看似劣于快速查找，但需注意O(N)只是上界。当树结构平衡时，两个操作都有较好表现。下一节我们将探讨如何保证其性能。

```java
public class QuickUnionDS implements DisjointSets {
    private int[] parent;

    public QuickUnionDS(int num) {
        parent = new int[num];
        for (int i = 0; i < num; i++) {
            parent[i] = -1;
        }
    }

    private int find(int p) {
        while (parent[p] >= 0) {
            p = parent[p];
        }
        return p;
    }

    @Override
    public void connect(int p, int q) {
        int i = find(p);
        int j= find(q);
        parent[i] = j;
    }

    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
}

# 5. 双链表结构

在第二章第二节中，我们构建了`SLList`类，其性能优于早期裸露的递归式`IntList`数据结构。本章将完善链表结构的讨论，并开始学习数组基础，为构建基于数组的列表`AList`做准备。同时，我们将揭示前一章使用`SLList`这一特殊名称的深层原因。

---

## 末位添加方法

观察前一章的`addLast(int x)`方法实现：

```java
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }
    p.next = new IntNode(x, null);
}
```

该方法存在效率问题：当处理长链表时，`addLast`需要遍历整个链表，这与第二章第二节的`size`方法效率问题类似。为解决此问题，可引入`last`指针优化：

```java
public class SLList {
    private IntNode sentinel;
    private IntNode last;
    private int size;    

    public void addLast(int x) {
        last.next = new IntNode(x, null);
        last = last.next;
        size += 1;
    }
    ...
}
```

**练习 2.3.1**：图示包含last指针的SLList实现结构。假设需要支持`addLast`、`getLast`和`removeLast`操作，当前结构能否高效实现这些操作？若否，哪些操作效率较低？

![[42ea14afa4be8739e338d48112c27047_MD5.jpg]]

**答案 2.3.1**：`addLast`和`getLast`操作高效，但`removeLast`效率低下。因为删除末节点后，无法快速获取倒数第二个节点来更新last指针。

---

## 倒数第二节点问题

练习2.3.1结构存在的核心问题在于：删除末节点操作需要定位倒数第二个节点。即使添加`secondToLast`指针，仍需处理三级节点的指针关系维护问题。

**练习 2.3.2**：尝试设计使`removeLast`操作恒定为常数时间复杂度的方案（无需编码实现）。

该问题解决方案将在改进方案#7中详述。

---

## 改进方案#7：逆向指针

自然解决方案是为每个`IntNode`添加前驱指针：

```java
public class IntNode {
    public IntNode prev;
    public int item;
    public IntNode next;
}
```

这种双向链接结构称为双链表（DLList）。相较于单链表（SLList），双链表需要更复杂的指针管理。以下图示展示了空链表（size=0）与双节点链表（size=2）的结构：

![[082618be9e598a416fd3c44ba47d150b_MD5.jpg]]

![[ea349c3828020364c7cb3eb0b1cdc9b0_MD5.jpg]]

---

## 改进方案#8：哨兵升级

双向指针使得链表能在常数时间内完成首尾增删操作。但存在哨兵节点与末节点指针的边界问题（思考：哪些DLList方法会出现特殊情况？）

解决方案一：在链表末端添加第二个哨兵节点：

![[5dbe4fedd5774073e56bdc1823096be4_MD5.jpg]]

![[320382b67b8d1fb31a01a751cddc0d2d_MD5.jpg]]

解决方案二：构建环形链表，使首尾指针共享哨兵节点：

![[c5c934ea5e3b0719ec94b7d19f83e709_MD5.jpg]]

![[ba3f97cb225a1fd00d7930299e452c96_MD5.jpg]]

两种方案均可消除特殊边界情况，其中环形结构更为优雅简洁。具体实现细节将在项目实践中深入探讨。

---

## 泛型双链表

当前DLList存在重大局限：仅支持整型数据存储。Java泛型（2004年引入）可解决此问题，允许创建支持任意引用类型的通用数据结构。

基本语法：类声明时在类名后添加类型占位符`<>`。示例改造：

原整型DLList声明：
```java
public class DLList {
    private IntNode sentinel;
    private int size;

    public class IntNode {
        public IntNode prev;
        public int item;
        public IntNode next;
        ...
    }
    ...
}
```

泛型改造后：
```java
public class DLList<泛型类型> {
    private IntNode sentinel;
    private int size;

    public class IntNode {
        public IntNode prev;
        public 泛型类型 item;
        public IntNode next;
        ...
    }
    ...
}
```

实例化示例：
```java
DLList<String> d2 = new DLList<>("hello");
d2.addLast("world");

DLList<Integer> d1 = new DLList<>(5);
d1.insertFront(10);
```

关键注意事项：
- 实现文件在类声明处指定泛型类型
- 使用文件声明时指定具体类型，实例化使用空钻石操作符
- 基本类型需使用包装类（Integer/Double等）

完整泛型实例化语法（右侧类型声明可选）：
```java
DLList<Integer> d1 = new DLList<Integer>(5);
```

通过掌握本章及前两章内容，读者已具备完成项目1中`LinkedListDeque`所需的全部知识体系。

# 8. ArrayList

---

在本节中，我们将构建名为`AList`的新类，用于存储任意长度的数据列表，类似于我们的`DLList`。与`DLList`不同，`AList`将使用数组而非链表存储数据。

---

### 链表性能谜题

假设我们想为`DLList`编写名为`int get(int i)`的新方法。为何对于长列表来说，`get`方法会比`getLast`慢得多？哪些输入会导致其特别缓慢？

下图可能有助于思考答案：

![[ba3f97cb225a1fd00d7930299e452c96_MD5.jpg]]

---

### 链表性能谜题解答

事实证明，若使用2.3节描述的双向链表结构，无论设计多么巧妙，`get`方法通常都会比`getBack`慢。

这是因为我们仅有对链表首尾节点的引用，要获取中间元素必须从头或尾开始遍历。例如，在10,000个元素的列表中获取第417项，需向前遍历417个链接。

最坏情况下（当目标项位于列表中间时），需遍历与列表长度成比例的项数（具体为总项数的一半）。这意味着`get`方法的最坏情况时间复杂度与列表规模呈线性关系，而`getBack`的时间复杂度是常数级，与列表大小无关。后续课程将用大O和大Theta符号正式定义时间复杂度。

---

### 初步尝试：基于数组的简单列表

现代计算机访问数组第i个元素的时间复杂度为常数级。这意味着基于数组的列表在`get`操作上比链表方案更具性能优势，因为它可以直接使用下标访问目标元素。

**为何数组支持常数时间访问？** 参见[Quora解释](https://www.quora.com/Why-does-accessing-an-array-element-take-constant-time)。

**可选练习2.5.1：** 尝试构建支持`addLast`、`getLast`、`get`和`size`操作的`AList`类，要求支持最多100个元素的数组。初始代码参见[GitHub仓库](https://github.com/Berkeley-CS61B/lectureCode/tree/master/lists4/DIY)。

[参考答案](https://github.com/Berkeley-CS61B/lectureCode/tree/master/lists4/naive)的关键不变量：
- 下一个插入位置（通过`addLast`）始终为`size`
- 列表项数始终为`size`
- 最后一项的位置始终为`size - 1`

---

### 实现removeLast

在实现`removeLast`前需明确关键原则：任何列表变更必须反映在实现中的一个或多个内存单元的修改。

**可选练习2.5.2：** 在保持不变量前提下编写`removeLast`方法，确保方法调用符合用户预期。

---

### 简单扩容策略

**可选练习2.5.3：** 假设`AList`处于下图状态，调用`addLast(11)`会发生什么？如何解决？

![[837bb938f6034a71b5f507e62cab3ad3_MD5.jpg]]

Java解决方案是创建更大数组并复制元素：

```java
int[] a = new int[size + 1];
System.arraycopy(items, 0, a, 0, size);
a[size] = 11;
items = a;
size = size + 1;
```

此过程称为"扩容"，实质是创建更大新数组而非改变原数组大小。

**练习2.5.4：** 实现支持扩容的`addLast(int i)`方法。

---

### 简单扩容策略分析

通过插入100,000次测试发现：`SLList`瞬间完成，而基于数组的列表需数秒。

**练习2.5.5：** 100容量数组执行两次`insertBack`，共需创建多少内存单元？假设及时垃圾回收，最大同时存在多少单元？

**练习2.5.6：** 从100容量数组开始，执行1,000次`addLast`需创建约多少内存单元？

下图显示`SLList`（上）与简单数组列表（下）的时间-操作次数关系。`SLList`呈直线（每次操作恒定时间），数组列表呈抛物线（每次操作线性时间）。插入100,000项时，数组方案耗时约为链表方案的100,000倍。

![[6e24dee555d47241931db7fec22b517c_MD5.jpg]]

---

### 几何扩容策略

通过乘法而非加法扩容解决性能问题：

```java
public void insertBack(int x) {
    if (size == items.length) {
           resize(size * RFACTOR);
    }
    items[size] = x;
    size += 1;
}
```

此策略使100,000次插入操作几乎瞬间完成，具体分析将在后续章节展开。

---

### 内存利用率

考虑插入1,000,000项后删除990,000项的情况，此时实际使用率仅为1%。定义利用率R=列表大小/数组长度，当R<0.25时数组容量减半。

![[ec0289aa64b195cad85010e7c3e8fe06_MD5.jpg]]

---

### 泛型AList

通过泛型改造使`AList`支持任意类型。注意Java创建泛型数组的特殊语法：

```java
Glorp[] items = (Glorp []) new Object[8];
```

删除元素时需置空引用避免内存滞留（loitering），即Java垃圾回收机制无法回收无引用对象。

```java
public Glorp removeLast() {
    Glorp x = getLast();
    items[size - 1] = null;  // 避免游荡引用
    size = size - 1;
    return x;
}
```

该实现细节可防止内存浪费，尤其在处理大型数据集时尤为重要。

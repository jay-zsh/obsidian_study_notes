
# 26.3 Trie 字符串操作

再探 Trie 之力。

Trie 虽具备常数级查找与插入能力，但性能未必优于 BST 或哈希表——后者可即时访问完整字符串，而 Trie 需逐字符遍历。然而在**字符串专项操作**领域，Trie 展现出显著优势。

其核心价值在于高效支持**前缀匹配**等操作。例如：
- `longestPrefixOf`：沿目标词逐字符比对 Trie，直至无法继续
- `keyWithPrefix`：定位前缀终点后返回所有剩余键

以下定义返回 Trie 所有键的 `collect` 方法（伪代码）：

```
collect():
    创建空结果列表 x
    遍历根节点子节点字符 c：
        调用 colHelp(c, x, root.next.get(c))
    返回 x

colHelp(String s, List<String> x, Node n):
    若 n.isKey 为真：
        x.add(s)  // 添加当前键
    遍历 n 的子节点字符 c：
        调用 colHelp(s + c, x, n.next.get(c))  // 递归构建路径
```

基于此实现 `keysWithPrefix`（返回含指定前缀的所有键）：

```
keysWithPrefix(String s):
    定位前缀终点节点 alpha
    创建空列表 x
    遍历 alpha 的子节点字符 c：
        调用 colHelp(s + c, x, alpha.next.get(c))  // 收集后续键
    返回 x
```

---

### 自动补全应用

搜索引擎（如 Google）的输入建议功能便依赖此类技术。以查询 "how are you doing" 为例，输入 "how are" 时系统即推荐完整查询。

Trie 实现方案：
1. 构建字符串到权值的映射（权值反映字符串重要性，如词频）
2. 数十亿字符串高效存储（节点共享减少冗余）
3. 用户输入时调用 `keysWithPrefix(x)`，返回权值最高的 10 个结果

核心挑战：短前缀可能匹配百万级结果，而实际仅需前 10 项。优化方案：
- 节点缓存子树最优权值，按权值降序遍历子节点
- 合并冗余节点形成 **基数 Trie**（Radix Trie），节点存储字符串片段（本文不深入探讨）

---

### 本章总结

掌握数据类型特性可极大提升数据结构效率。针对字符串键的映射/集合，Trie 优势显著：
- 理论搜索/插入性能优于哈希表或平衡搜索树
- 子节点存储三方案（哈希表最自然）

| 实现方式               | 缺点     | 优点   |
| ------------------ | ------ | ---- |
| DataIndexedCharMap | 空间消耗大  | 速度最优 |
| Bushy BST          | 子节点检索慢 | 空间高效 |
| Hash Table         | 单链接成本高 | 空间高效 |

- 支持独有字符串操作：
  - `longestPrefixOf` 与 `keysWithPrefix` 因字符级存储天然实现
  - `keysWithPrefix` 赋能自动补全等算法（可结合优先队列优化）

名称 | 键类型 | get(x) | add(x)
----|--------|--------|-------
平衡 BST | 可比较 | Θ(logN) | Θ(logN)
分离链哈希表 | 可哈希 | Θ(1)† | Θ(1)∗†
数据索引数组 | 字符 | Θ(1) | Θ(1)
Trie (BST/HT/DICM) | 字符串 | Θ(1) | Θ(1)

\* 平均情况 † 数据均匀分布
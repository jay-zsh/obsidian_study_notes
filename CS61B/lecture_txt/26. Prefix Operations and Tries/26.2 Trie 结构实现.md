
# 26.2 Trie 结构实现

以经典学术之道实现 Trie。

以下展示 Trie 的基础实现方案：每个节点存储字符、子节点及颜色标识。利用先前定义的 `DataIndexedCharMap` 类管理子节点（子节点数量上限为字符集大小）：

```java
public class TrieSet {
   private static final int R = 128; // ASCII
   private Node root;    // Trie根节点

   private static class Node {
      private char ch;  
      private boolean isKey;   
      private DataIndexedCharMap next;

      private Node(char c, boolean blue, int R) {
         ch = c; 
         isKey = blue;
         next = new DataIndexedCharMap<Node>(R);
      }
   }
}
```

需注意：若节点子节点稀少，`DataIndexedCharMap` 将存在大量空值（如单子节点时127个空位）。此设计导致显著空间浪费，后续将探索优化方案。

关键洞察：链接仅当字符**实际存在**时才有效。故可移除节点的字符变量，改由父节点映射位置隐式确定：

```java
public class TrieSet {
   private static final int R = 128; // ASCII
   private Node root;    // Trie根节点

   private static class Node {
      // 移除字符变量
      private boolean isKey;   
      private DataIndexedCharMap next;

      private Node(boolean blue, int R) {
         isKey = blue;
         next = new DataIndexedCharMap<Node>(R);
      }
   }
}
```

---

## 性能分析

对于含 N 个键的 Trie，映射/集合操作时间复杂度如下：
- `add`：Θ(1)  
- `contains`：Θ(1)  

此结果与键数量无关——最坏情况仅遍历单个键的长度。引入更精确度量 L（键长度）重新分析：
- `add`：Θ(L)  
- `contains`：Θ(L)  

我们在无需考虑摊还调整或键均匀分布的前提下实现恒定时间复杂度！但当前设计因每个节点维护全字符集数组导致内存效率低下。

---

## 优化：子节点追踪

针对空间浪费问题，提出两种解决方案：
- **方案1**：基于哈希表的 Trie。不预分配128位数组，按需初始化并依据负载因子动态调整。
- **方案2**：基于BST的 Trie。仅当必要时创建子节点指针，子节点存储于BST中（需权衡BST检索开销）。

Trie 实现需选择子节点映射结构。映射作为抽象数据类型（ADT），其底层实现可灵活选择，体现实现与ADT间的**抽象屏障**优势：

| 实现方式           | 空间成本         | 时间复杂度       |
|--------------------|------------------|------------------|
| DataIndexedCharMap | 每节点128个链接  | Θ(1)             |
| BST                | 每节点C个链接*   | O(log R)**       |
| 哈希表             | 每节点C个链接*   | O(R)**           |

\* C=实际子节点数  
\** R=字符集大小（固定值，可视为常数时间）  

核心结论：BST/哈希表与DataIndexedCharMap存在内存与效率的权衡。Trie操作仍保持恒定时间复杂度，且在特定操作中表现卓越。

# 26.1 Trie 结构导论

行或不行。没有"尝试"之说。（注：Trie与try同音）

首先探讨现有哈希映射实现的潜在优化方案。  
哈希映射已具备卓越性能：基于分离链的弹性哈希表中，`contains(x)` 方法时间复杂度为 Θ(1)（假设均匀分布），`add(x)` 方法同样为 Θ(1)（假设均匀分布且摊还分析）。虽已达理论最优，但若掌握数据特性可进一步突破。

---

## 特例 1：字符键映射

当键仅为 ASCII 字符时，可弃用通用哈希映射，改用数组索引直接映射字符：

```java
public class DataIndexedCharMap<V> {
    private V[] items;
    public DataIndexedCharMap(int R) {
        items = (V[]) new Object[R];
    }
    public void put(char c, V val) {
        items[c] = val;
    }
    public V get(char c) {
        return items[c];
    }
}
```

此实现中 R 表示字符集大小（如 ASCII 为 128）。通过牺牲内存消除桶结构对性能的影响，确保数据均匀分布。

---

## 特例 2：字符串键映射

当键恒为字符串时，可采用 Trie 数据结构。该结构将字符串各字符存储为树节点，在单词检索、添加及特殊字符串操作中表现卓越。

---

## Trie 结构演示

假设需存储 "sam", "sad", "sap", "same", "a", "awls" 等词，目标数据结构需明确标识完整单词（排除前后缀）。Trie 核心特性：
- 单节点仅存储单个字符
- 节点可被多键共享

初始包含 "sam" 和 "sad" 的 Trie：  
![[PANG/f0e546d91e692a57569ac6ee3de18761_MD5.jpg]]

添加 "sap" 时复用 "sa" 前缀：  
![[PANG/dfb34ef24e51561dcd30bb39516632a5_MD5.jpg]]

添加 "same" 时复用 "sam" 前缀：  
![[PANG/4b529f033e97eaa6475005f6eaf3c3a2_MD5.jpg]]

添加 "a" 时需新建独立节点（避免与 "ame" 混淆）：  
![[PANG/5377a3086c7f08d73b5c481428ab1993_MD5.jpg]]

添加 "awls" 时复用 "a" 前缀：  
![[PANG/8afbb7457c2090001833b5df8e80fc0d_MD5.jpg]]

为区分完整单词与前缀，将词尾字符标记为蓝色：  
![[PANG/c51b46f4ea32e80acd0ba68d0c572a38_MD5.jpg]]

检索规则：沿根节点逐字符遍历，仅当抵达蓝色节点且未脱离树结构时命中。  
示例：
- `contains("sam")`：命中（蓝节点）
- `contains("sa")`：未命中（白节点）
- `contains("a")`：命中（蓝节点）
- `contains("saq")`：未命中（脱离树结构）

---

## Trie 作为映射结构

通过在节点存储数据，Trie 可扩展为映射结构。例如蓝节点附加数值可表示单词频次。

---

# 35.1 计数排序

想象一下，如果我们不开慢吞吞的本田思域，而是开一辆快速的法拉利。不幸的是，今天我们实际上不会开法拉利，但我们将见证一种同样快速的算法，称为基数排序。

在对数组进行排序时，排序在最坏情况下（数组按降序排列）需要 $$Ω(NlogN)$$ 次比较操作。因此，基于比较的排序算法的最坏情况运行时间为 $$Θ(NlogN)$$。

从渐近角度来看，这意味着无论我们多么聪明，都无法超越归并排序的最坏情况运行时间 $$Θ(NlogN)$$。但如果我们根本不比较呢？

![](6fc7d064206374f21be8f88e7580e7b4_MD5.jpg)

左边是原始数据，右边是有序输出

本质上，我们首先创建了一个相同大小的新数组，然后将所有索引复制到正确的位置。因此，我们首先查看 5 Sandra Vanilla Grimes，然后将其复制到新数组的第 5 个索引位置。

这确实保证了 $$Θ(N)$$ 的最坏情况时间。然而，如果我们处理的是：

- 非唯一键。
- 非连续键。
- 非数值键。

所有这些情况都是复杂的案例，处理起来不那么简单。本质上，我们可以创建一个更简单的方法：

- 计算每个项目的出现次数。
- 遍历列表，使用计数数组来决定每个元素的位置。

总之，我们可以使用计数排序在 $$Θ(N)$$ 时间内对 N 个对象进行排序。
# 35.3 MSD基数排序
---
基本思想：类似于LSD，但从最左边的数字开始向右排序。

假设我们按最高位排序，然后中间位，最后最低位。我们会得到正确结果吗？

![](PANG/2327f29568e11631e2e0a5d2a33b2f6c_MD5.jpg)

MSD基数排序（正确版本）

注意，首先我们按最左边的数字排序。然后我们根据最左边的数字对数据进行分组，因此一组以'a'开头，下一组以'b'开头，依此类推。然后在我们的子组中，我们按中间位排序，并创建新的子组。最后，我们将这些分解为更小的子组，直到所有子问题都独立。最终结果将是排序好的。

---
### 运行时间
---
**最佳情况**
- 我们只需一次计数排序遍历，仅查看最高位：$$Θ(N+R)$$

**最坏情况**
- 必须检查每个字符，退化为LSD排序：$$Θ(WN+WR)$$

---
### 运行时间总结
---

| 算法名称         | 内存占用      | 最坏运行时间               | 备注                                | 是否稳定 |
|------------------|-------------|--------------------------|-----------------------------------|--------|
| 堆排序(Heapsort) | Θ(1)        | O(N log N)*              | 缓存性能差(61C)                     | 否      |
| 插入排序(Insertion) | Θ(1)      | O(N²)*                  | 小规模数据/近乎有序时最快              | 是      |
| 归并排序(Mergesort) | Θ(N)      | O(N log N)*             | 最快的稳定排序算法                   | 是      |
| 随机快速排序(Random Quicksort) | Θ(log N) | O(N log N)* 期望值       | 最快的比较类排序                    | 否      |
| 计数排序(Counting Sort) | O(N+R)    | O(N+R)                  | 仅适用于字母键                       | 是      |
| LSD基数排序       | Θ(N+R)      | O(WN+WR)                | 仅适用于字母键字符串                 | 是      |
| MSD基数排序       | Θ(N+WR)     | O(N+R) (最佳)<br>O(WN+WR) (最差) | 缓存性能差(61C)                     | 是      |

# 32.1 快速排序变体 vs. 归并排序

---

## 快速排序变体：动机

在深入探讨如何改进快速排序算法的精妙思路前，请先回顾[快速排序（或分区排序）](https://cs61b-2.gitbook.io/cs61b-textbook/30.-quicksort/30.2-quicksort-algorithm)的工作原理。

回顾一下，我们的快速排序版本具有以下特性：
- 最左侧元素始终作为枢轴
- 分区算法始终保留 ≤ 和 ≥ 元素的相对顺序

请记住，即使我们拥有一个始终“良好”的枢轴（其最佳运行时间为 θ(NlogN)），实践中仍可能发生罕见的 θ(N²) 最坏情况运行时间。因此，快速排序的运行时间可能劣于[归并排序](https://cs61b-2.gitbook.io/cs61b-textbook/15.-asymptotics-ii/15.4-mergesort)，失去其“最快排序算法”的称号。

因此，一个自然的问题是：**我们如何避免快速排序陷入最坏情况？** 从而确保其击败归并排序？这将是本节探索的核心动机。

---

## 快速排序变体：哲学理念

以下是改进快速排序的通用哲学理念：

### 理念一：随机性

实践中出现罕见最坏情况运行时间的原因可能包括：
- 不良顺序：数组已排序
- 不良元素：数组元素全为重复值

在上述两种情况下，若采用最左侧元素始终为枢轴的策略，围绕枢轴的分区操作**无法显著缩减子数组规模**，导致需多次遍历元素。

解决不良顺序问题的一种方案是随机性，体现为以下两种策略：
1. 随机选择枢轴
2. 排序前打乱元素顺序

注意：策略二需在分区代码中谨慎处理，以避免重复值数组上的 θ(N²) 行为。

事实证明，这种随机化版本的快速排序是性能极佳的最佳排序算法。正如1992年电视剧《Renegade》中那位无忧无虑的摩托车骑手，此版本快速排序算法以无所畏惧的态度蓬勃发展——即使没有那奢华的发型。

![](5b8ea71413293078c5d54001a372fcec_MD5.jpg)

随机化快速排序算法的精神。

---

### 理念二：更智能的枢轴选择

另一种解决方案是高效选择“良好”枢轴。

#### 2a. 常数时间枢轴选择

一种方法是选取少量元素，并从中选择“最佳”作为枢轴。此类方法体现了**确定性**且**常数时间**的枢轴选择过程。然而，其重大缺陷在于：生成的快速排序存在一系列“危险输入”（导致最坏运行时间或破坏算法的输入），对手可轻易生成此类输入。

#### 2b. 线性时间枢轴选择

由于需多次分区，始终选择中位数作为枢轴似乎是理想方案，因为每次分区可将子数组规模减半。因此，为改进2a方案，我们可计算数组的**中位数**（线性时间内完成），并将其选为枢轴。

“精确中位数快速排序”算法虽无2a方案的技术漏洞，且运行时间为 θ(NlogN)，但仍慢于归并排序。

---

### 理念三：自省

此理念仅依赖于监控算法的递归深度，并在达到深度阈值时切换至归并排序。尽管合理，但实践中并不常用。

---

## 快速排序变体 vs. 归并排序：孰优孰劣？

### 候选一：快速排序 L3S

快速排序 L3S 是先前介绍的版本，具有以下特性：
- 始终选择最左侧元素为枢轴
- 分区操作
- 起始前打乱顺序

![](93c4f30ec54502aef206855ca55030ca_MD5.jpg)

遗憾，归并排序以 0 : 1 领先。

---

### 候选二：快速排序 LTHS

快速排序 LTHS 与 L3S 高度相似，但采用不同分区方案：[Tony Hoare 原地分区方案](https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/pub?start\=false&loop\=false&delayms\=3000&slide\=id.g12b16fb6b6_0_2)。

#### Tony Hoare 分区

设想两个指针，分别位于数组两端并向中间移动：
- 左指针偏好小元素
- 右指针偏好大元素
- 核心思想：相向移动，交换不满足条件的元素；指针交叉时停止
  - 左指针厌恶 ≥ 枢轴的元素
  - 右指针厌恶 ≤ 枢轴的元素
- 新枢轴 \= 右指针处元素
- 最终结果：枢轴（原最左侧元素）左侧为“小”元素，右侧为“大”元素

#### TH 分区：直观类比

直观上，可将每个指针视为“小于枢轴”和“大于枢轴”区域的“警察”，枢轴则是两区域间的“分界线”。其职责是逮捕各自区域内的“嫌疑元素”（不属于该区域的元素），并与对方“警察”交换。

具体而言，左指针是“小于枢轴”区域的警察，搜寻分界线此侧不应存在的“嫌疑元素”（≥ 枢轴）；右指针则在“大于枢轴”区域搜寻“嫌疑元素”（≤ 枢轴）。当两“警察”相遇时，任务完成——双方已彻底搜查各自辖区。

#### 这一切努力徒劳无功？

绝非如此！新分区方案的付出终得回报：使用 TH 方案可生成极快的快速排序——超越归并排序！需注意：
- 后续已发现更快的方案
- 整体运行时间仍关键依赖于枢轴选择策略！

![](69d15affd314b9221fa8b20cd2ccc4bd_MD5.jpg)

快速排序变体以 1 : 1 扳回一局！

---

### 候选三：快速排序 PickTH

#### 中位数识别：线性时间

回顾理念2b，识别中位数并用作枢轴的思路效率低下，因查找中位数本身代价高昂（运行时间：θ(NlogN)）。实际上，通过“[PICK](https://www.cs.princeton.edu/~wayne/cs423/lectures/selection-4up.pdf)”算法，可在 θ(N) 时间内找到中位数。

改进版精确中位数快速排序能否优于归并排序？

![](8bb31808ca8d319b3ac28977b5c67f13_MD5.jpg)

遗憾，未能实现！且表现糟糕！可能原因：
- 计算中位数的成本过高
- 若追求实际性能，仍需承受最坏情况 θ(N²)

归并排序以 1 : 2 获胜。
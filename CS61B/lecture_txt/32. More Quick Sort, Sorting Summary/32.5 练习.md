# 32.5 练习

---

## 

事实性问题

1. 假设我们有数组 `[17, 15, 19, 32, 2, 26, 41, 17, 17]`，使用三向扫描分区并以 `17` 为枢轴进行分区后，最终得到的数组是什么？
    
2. 假设我们有数组 `[17, 15, 19, 32, 2, 26, 41, 17, 17]`，使用托尼·霍尔分区并以 17 为枢轴进行分区后，最终得到的数组是什么？
    

问题1  
`[15, 2, 17, 17, 17, 19, 32, 26, 41]`。首先扫描较小元素（15, 2），然后扫描相等元素（17, 17, 17），最后扫描较大元素（19, 32, 26, 41），顺序与原始数组从左到右一致。

问题2  
`[2, 15, 17, 17, 17, 26, 41, 32, 19]`。演示参见此处。

---

## 

概念性问题

1. 若使用始终以最左端元素为枢轴的快速排序，并采用稳定分区策略，以下哪个数组会导致 N² 时间复杂度？
    
    - `[1, 1, 1, 1, 1, 1, ..., 1]`
        
    - `[1, 2, 3, 4, 5, 6, ..., N]`
        
    - `[N, N - 1, N - 2, N - 3, ... 2, 1]`
        
    
2. 重复上述问题，但假设分区前对数组进行了洗牌。
    
3. 若使用快速选择算法在 `[17, 15, 19, 32, 2, 26, 41, 5, 9]` 中查找中位数，需要多少次分区操作？
    
4. 以下哪些排序算法是稳定的？
    
    - 插入排序
        
    - 快速排序 L3 - 以最左端元素为枢轴，使用三向扫描分区
        
    - 快速排序 L3S - 以最左端元素为枢轴，使用三向扫描分区，起始前洗牌
        
    - 快速排序 LTH - 以最左端元素为枢轴，使用托尼·霍尔分区
        
    - 快速排序 PickTH - 以中位数（通过 PICK 计算）为枢轴，使用托尼·霍尔分区
        
    

问题1  
这三个数组都是快速排序的最坏情况输入，因为最大分区的规模每轮分区仅减少 1：
- `[1, 1, 1, 1, 1, 1, ..., 1]`
- `[1, 2, 3, 4, 5, 6, ..., N]`
- `[N, N - 1, N - 2, N - 3, ... 2, 1]`

问题2  
若洗牌后，两个含整数至 `N` 的数组不再必然产生劣质枢轴，因为枢轴可能等概率为数组中任意元素。但全 `1` 数组仍始终选择"劣质"枢轴，因所有元素相等且最终位于左分区：
- `[1, 1, 1, 1, 1, 1, ..., 1]`
- `[1, 2, 3, 4, 5, 6, ..., N]`
- `[N, N - 1, N - 2, N - 3, ... 2, 1]`

问题3  
1 次；单次分区操作后，17 位于数组中间位置。因此我们将 17 置于此位置并立即完成。注意：所用分区策略不影响结果。

问题4  
插入排序是稳定的（如前章所述）。  
仅三向扫描分区是稳定的。  
洗牌后无法保证元素顺序，故涉及洗牌的分区策略均不稳定。霍尔分区本质不稳定，因此任何含霍尔分区的排序均非稳定：
- 插入排序
- 快速排序 L3 - 以最左端元素为枢轴，使用三向扫描分区
- 快速排序 L3S - 以最左端元素为枢轴，使用三向扫描分区，起始前洗牌
- 快速排序 LTH - 以最左端元素为枢轴，使用霍尔分区
- 快速排序 PickTH - 以中位数（通过 PICK 计算）为枢轴，使用霍尔分区

---

## 

元认知问题

1. 为何 Java 内置的 `Array.sort` 方法对 `int`、`long`、`char` 等基本类型数组使用快速排序，而对所有 `Object` 数组使用归并排序？
    
2. 既然快速排序在始终选择中位数作为枢轴时最快，为何不通过快速选择算法寻找中位数来优化枢轴选择（而非使用最左端元素）？
    

问题1  
这是因为基本类型无需稳定性——相等的 `int` 无法通过 `.equals()` 区分。但 `Object` 不同，不同内存地址的两个对象可能相等，且对象排序时可能需要稳定性。

问题2  
每次分区前寻找中位数会显著增加时间成本，导致实际运行效率降低。遭遇最坏情况快速排序的概率极低，因此在多数排序场景中，使用耗时算法寻找中位数得不偿失。
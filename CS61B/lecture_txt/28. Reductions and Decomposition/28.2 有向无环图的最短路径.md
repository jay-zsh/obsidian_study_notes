
# 28.2 有向无环图的最短路径
---
回顾前文，**有向无环图（DAG）** 是**有向无环的图结构**。在DAG上求解最短路径时，虽可使用[Dijkstra算法](https://cs61b-2.gitbook.io/cs61b-textbook/24.-shortest-paths/24.2-dijkstras-algorithm)，但针对DAG存在更简洁的算法——该算法甚至能处理负权边！
---
### Dijkstra算法在负权边下的失效
Dijkstra算法依赖"访问某边即已找到其最短路径"的假设，负权边会破坏此假设。考察下例：

![[ba920daa164f812aef53ba5f936e767f_MD5.jpg]]

从A出发时，Dijkstra将先访问C再访问B（完全忽略边 _**B→C**_¹）。当然，负权边不必然导致失效，如下例仍可正确求解：

![[c1395004c48293a30cef2b345ca5f21b_MD5.jpg]]

> ¹ 实际行为取决于实现：若松弛步骤仅考虑未访问节点，则 _**B→C**_ 不被处理；若无此限制，访问B时会更新C的距离。但后者违反Dijkstra核心不变式——"节点出队时已获最短路径"。
---
### DAG最短路径算法
按拓扑序访问顶点：
- 访问每个顶点时，松弛其所有出边

边 _**u→v**_（权重w）的松弛定义为：
```python
if distTo[u] + w < distTo[v]:
    distTo[v] = distTo[u] + w
    edgeTo[v] = u
```

因按拓扑序访问，处理顶点时其所有可能路径信息已完备。这意味着即使存在通往v的负权路径，算法在访问v前已考量其影响。

拓扑排序耗时$O(V+E)$，松弛操作总耗时亦为$O(V+E)$，故整体时间复杂度为$O(V+E)$。相较之下，Dijkstra因最小堆操作需$O((V+E)logV)$时间。

> 对于含负权边的非DAG图，可扩展使用[Bellman-Ford算法](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)，此超出课程范围。
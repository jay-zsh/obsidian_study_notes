
# 28.1 拓扑排序与有向无环图
---
迄今为止，我们已涵盖大量内容：编程实践、IDE使用、数据结构设计、渐进分析、多种抽象数据类型实现（如使用二叉搜索树、字典树或哈希表实现映射，堆实现优先队列），以及图算法。

> 这些知识为何重要？

您可能听闻CS 61B教授了解决科技公司标准面试题所需的大部分知识——但企业为何青睐具备这些特定技能的候选人？

关键原因在于，许多现实问题可通过已学的数据结构和算法建模解决。本章将运用现有工具解决若干复杂问题。
---
### 拓扑排序
假设存在若干相互依赖的任务，如何排序使得每个任务 _**v**_ 的前置任务均位于 _**v**_ 之前？

可将任务集合建模为图：节点代表任务，边 _**v**_**→**_**w**_ 表示 _**v**_ 需先于 _**w**_ 完成。问题即转化为寻找**拓扑排序**。

> **拓扑排序：** 图的顶点排序，满足每条有向边 _**u**_→_**v**_ 中，_**u**_ 在排序中位于 _**v**_ 之前。

![[PANG/8bd83567a2a99045590c2f1a727e038a_MD5.jpg]]

**问题 1.1：** 上图有哪些有效拓扑排序？

需注意拓扑排序仅适用于特定图类型。考察下图：

![[PANG/f87f1a14c1c2bbe48c0e068f0fd98517_MD5.jpg]]

其有效拓扑排序为何？

![[PANG/e050e0ec0b22352fc561e2b6969a2c50_MD5.jpg]]

故拓扑排序仅适用于**有向无环图（DAG）**。

> **拓扑排序：** **DAG** 的顶点排序，满足每条有向边 _**u**_→_**v**_ 中，_**u**_ 在排序中位于 _**v**_ 之前。

对于任意拓扑排序，可重绘图使顶点线性排列，故拓扑排序亦称图的**线性化**。例如下图为前例的线性化形式：

![[PANG/3e04e35fa8ace10900692fd3aca073c5_MD5.jpg]]

该DAG的拓扑排序须以D或E起始，以F或C结束，故D、E称为_源点_，F、C称为_汇点_。

拓扑排序  
如何实现拓扑排序？请思考现有图算法中哪些可解决此问题。

拓扑排序算法：
- 从每个顶点执行DFS遍历，**不**清除遍历间标记
- 记录DFS后序遍历序列
- 拓扑排序为后序序列的逆序

**原理：** 顶点 _**v**_ 仅在其所有后代被访问后才加入后序列表。反转列表即保证所有后代位于 _**v**_ 之后。

因仅使用DFS，时间复杂度为**O(V+E)**（**V**、**E** 分别为节点数和边数）。

#### 伪代码
```python
topological(DAG):
    initialize marked array
    initialize postOrder list
    for all vertices in DAG:
        if vertex is not marked:
            dfs(vertex, marked, postOrder)
    return postOrder reversed

dfs(vertex, marked, postOrder):
    marked[vertex] = true
    for neighbor of vertex:
        dfs(neighbor, marked, postOrder)
    postOrder.add(vertex)
```

**（拓展）如何用BFS实现拓扑排序？**  
_提示1：需存储额外信息_  
_提示2：考虑跟踪各顶点入度_
---
### 复习
- 拓扑排序是**有向无环图（DAG）** 的线性化方法
- 使用**DFS**或**BFS**可在**O(V+E)**时间内求解任意DAG的拓扑排序
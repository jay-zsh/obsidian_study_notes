
# 30.5 练习

---

## 事实性

1.  假设我们在 Java 中有一个已排序的数组。在数组中查找特定项的最佳方法是什么：二分查找还是线性遍历？
    
2.  对存储在物理磁带上的已排序数组重复上述练习。
    
3.  给定数组 `[90, 50, 20, 30, 40, 10, 60, 50, 30]`，最佳枢轴是什么？
    

**问题 1**
二分查找。二分查找的时间复杂度为 log⁡N（其中 N 是数组长度）。

**问题 2**
在物理磁带上，算法的运行时间主要受物理磁带加速时间支配。最坏情况下，二分查找需要扫描到磁带中点，然后回退四分之一，再前进八分之一，依此类推。最坏情况下，我们需要覆盖 N/2 + N/4 + N/8 + ... + 1 即 O(N) 的磁带空间。然而，反复加速将导致最坏情况下的算法速度几乎肯定低于直接向前扫描。

**问题 3**
40；它是中位数，能均匀划分数组。

---

## 程序性

1.  若有 10 个待排序项，选择排序需要多少次比较？
    
2.  快速排序递归树在最佳和最坏情况下的深度是多少？请给出精确答案，而非渐近界。
    

**问题 1**
共 45 次；首先进行 9 次比较找到最小项，然后 8 次，再 7 次，以此类推。1 + 2 + 3 + ... + 9 = 45。

**问题 2**
最坏情况下，若始终选择最小或最大项作为枢轴，则需进行 N 次递归调用。因此递归树深度为 N。
最佳情况下，始终选择中位数作为枢轴。这会使数组规模在每层减半，从而产生 log⁡₂N 层。

---

## 元认知

1.  假设快速排序始终选择最左侧项作为枢轴。指出会导致最坏运行时间的三种数组类型。划分时，假设划分为两个数组：小于等于枢轴的项，以及大于枢轴的项。
    

**问题 1**
三种数组类型为：
1.  已按顺序排列的数组：枢轴始终是最小项，其左侧无任何元素。
2.  逆序排列的数组：与 (1) 问题相同，但枢轴始终是最大项。
3.  所有项均相等的数组：所有项都会被划分到左侧（小于等于枢轴），右侧无任何项。

[上一章 30.4 总结](https://cs61b-2.gitbook.io/cs61b-textbook/30.-quicksort/30.4-summary)[下一章 31. 软件工程 II](https://cs61b-2.gitbook.io/cs61b-textbook/31.-software-engineering-ii)

最后更新于 2 年前

30.5 练习 | CS61B 教材

# 11.4 比较器

我们刚刚学习了`Comparable`接口，它赋予每个`Dog`对象与其他同类比较的能力。现在我们将介绍一个外观相似但功能不同的新接口——`Comparator`。

首先明确两个核心概念：

- **自然顺序**——指类通过`compareTo`方法隐式定义的排序规则

以`Dog`类为例，其自然顺序由体型大小决定。若我们需要按名称字母顺序排序，该如何实现？

Java通过`Comparator`接口实现这一需求。由于比较器本身是独立对象，我们通常在`Dog`类内部创建实现`Comparator`接口的静态嵌套类。

先观察接口定义：

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

该接口要求实现类必须包含`compare`方法，其规则与`compareTo`一致：

- 当o1 < o2时 return negative number
- 当o1 \=\= o2时 return 0
- 当o1 > o2时 return postive number

以下实现名称比较器的示例（注意`String`类自身的`compareTo`方法被复用）：

```java
import java.util.Comparator;

public class Dog implements Comparable<Dog> {
    ...
    public int compareTo(Dog uddaDog) {
        return this.size - uddaDog.size;
    }

    private static class NameComparator implements Comparator<Dog> {
        public int compare(Dog a, Dog b) {
            return a.name.compareTo(b.name);
        }
    }

    public static Comparator<Dog> getNameComparator() {
        return new NameComparator();
    }
}
```

注意`NameComparator`被声明为静态内部类——这意味着无需实例化`Dog`对象即可获取比较器。调用方式如下：

```java
Comparator<Dog> nc = Dog.getNameComparator();
```

通过这种设计，我们实现了：
1. 在`Dog`类内部封装名称比较器
2. 提供获取比较器的公共方法
3. 保持类层次结构的清晰性

![[826137c6e11009dd0ba391c713220a78_MD5.jpg]]

总结：
- **回调机制**：Java接口实现了回调模式。当某个功能需要依赖未确定的辅助方法时（如`max`需要`compareTo`），通过接口封装所需方法
- **`Comparable`** 声明对象自身的比较能力，定义类型的自然顺序
- **`Comparator`** 作为独立比较器，提供多样化的比较方式。当需要多种比较规则时，必须使用比较器

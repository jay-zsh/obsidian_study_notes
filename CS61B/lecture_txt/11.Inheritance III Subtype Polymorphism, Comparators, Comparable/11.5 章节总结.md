# 11.5 章节总结

## **回顾：类型规则**

- 编译器允许内存容器持有任何子类型
    
- 编译器允许基于静态类型进行调用
    
- 重写的非静态方法在运行时根据动态类型选择
    
- 对于重载方法，方法在编译时选择
    

---

## **子类型多态性**  
考虑静态类型为`Deque`的变量。调用`deque.method()`的行为取决于动态类型。因此，我们可以实现`Deque`接口的多个子类，所有子类都能调用`deque.method()`。

---

## **子类型多态性示例**  
假设我们需要编写一个`max()`函数，无论类型如何都能返回数组中的最大值。如果我们编写`max(Object[] items)`方法，并使用`>`运算符比较数组中的每个元素，这种方法将失效！原因何在？

因为这种方法假设所有对象都可比较，但某些对象并不具备可比性！或者，我们可以在`Dog`类中编写`max()`函数，但这意味着需要为每个需要比较的类都编写`max()`函数！请记住，我们的目标是编写一个适用于所有可比较对象的"唯一真理max方法"。

---

## **解决方案：OurComparable接口**  
解决方案是创建一个包含`compareTo(Object)`方法的接口（命名为`OurComparable`）。现在，`max()`方法可以接受`OurComparable[]`参数。由于我们保证任何实现该接口的对象都包含接口中的方法，因此我们始终可以调用`compareTo`方法，且该方法能正确返回对象的某种排序。

现在我们可以定义"唯一真理max方法"。当然，任何需要比较的对象必须实现`compareTo`方法。但与在每个类中重新实现`max`逻辑不同，我们只需实现两个对象间的排序逻辑。

---

## **更优方案：Java内置的Comparable**  
Java内置的`Comparable`接口通过泛型避免了类型转换问题。此外，`Comparable`已支持`Integer`、`Character`和`String`等类型，这些类型已预先实现了`max`、`min`等方法。因此我们无需重复已实现的功能！

---

## **比较器（Comparators）**  
"自然顺序"指由`Comparable`的`compareTo`方法隐式定义的排序。但如果我们希望按`size`以外的属性排序`Dog`对象？此时可传入需要`compare()`方法的`Comparator<T>`接口，通过自定义`compare()`方法实现任意排序逻辑。

# 11.1 动态方法选择回顾

---

在之前的课程中，我们学习了类的继承关系。理解继承需要判断子类与父类是否存在"is-a"关系。例如以下两个类：

- Dog（犬类）：实现bark()方法
    
- ShowDog（表演犬）：继承Dog类，重写bark方法
    

这种继承是有效的，因为ShowDog是Dog（犬类），而Dog又是Object（对象）。这些关系满足子类必须"是"父类实例的条件。

![[1e6159fba9df6b196ff17d1b6e8b3983_MD5.jpg]]

---

## 如何判断代码能否运行或报错？

这个问题较为复杂，但可遵循以下规则：

- 编译器允许内存容器存储其自身的任何子类型
    
    - 例如：编译器允许Dog内存容器存储ShowDog对象，因为ShowDog是Dog类的子类型
        
    
- 编译器允许基于静态类型进行方法调用
    
    - 例如：声明为Dog类型的变量，其静态类型是Dog，编译器允许它调用bark()
        
    
- **被重写的非静态方法在运行时根据动态类型选择**
    
    - **其他所有情况（包括重载方法）都基于静态类型**
        

---

## 静态类型 vs 动态类型

Java中的每个变量都有"编译时类型"（即静态类型）：

- 该类型在变量声明时确定，永不改变

变量同时具有"运行时类型"（即动态类型）：

- 该类型在实例化时确定（例如使用new操作符）
    
- 等同于变量当前指向对象的实际类型
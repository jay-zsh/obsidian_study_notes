# 7. 测试

---

### 测试与选择排序

中高级程序员最重要的技能之一是判断代码正确性的能力。本章将探讨如何编写测试来评估代码正确性，并在此过程中介绍选择排序算法。

---

#### 全新思路

编写程序时难免存在错误。在课堂环境中，我们通过用户交互、代码分析和自动化测试来建立对代码正确性的信心，其中自动化测试通常是最重要的验证手段。

自动化测试本质上与开发人员编写的代码并无不同。本章我们将创建`Sort`类，其核心方法`sort(String[] x)`能对数组`x`进行原地排序。

我们将采用全新思路：先编写`testSort()`测试用例，再实现排序逻辑。

---

#### 临时测试方案

为`Sort.sort`编写测试虽直接但稍显繁琐。基本思路是构造输入数据，调用方法后验证输出。若发现不匹配则输出首个错误点：

```java
public class TestSort {
    /** 测试Sort类的排序方法 */
    public static void testSort() {
        String[] input = {"i", "have", "an", "egg"};
        String[] expected = {"an", "egg", "have", "i"};
        Sort.sort(input);
        for (int i = 0; i < input.length; i += 1) {
            if (!input[i].equals(expected[i])) {
                System.out.println("位置" + i + "不匹配，预期：" + expected + "，实际：" + input[i]);
                break;
            }
        }
    }

    public static void main(String[] args) {
        testSort();
    }
}
```

使用空实现的`Sort.sort`进行测试时：

```java
public class Sort {
    /** 原地排序字符串数组 */
    public static void sort(String[] x) {        
    }
}
```

运行后将输出错误信息，这恰验证了测试的有效性。这种自验证机制如同构建自动化评审系统，驱动我们完善代码。

**重要提示**：数组比对不能直接使用`==`运算符，因其比较内存地址而非内容。建议使用循环或`java.util.Arrays.equals`方法。

---

#### JUnit测试框架

使用Google Truth库可大幅简化测试代码：

```java
import static com.google.common.truth.Truth.assertThat;
public class TestSort {
   @Test
   public void testSort() {
       String[] input = {"cows", "dwell", "above", "clouds"};
       String[] expected = {"above", "clouds", "cows", "dwell"};
       Sort.sort(input);
       assertThat(input).isEqualTo(expected);
   }
}
```

当`Sort.sort`未实现时，测试将输出详细错误信息。虽不如自定义提示直观，但能准确定位问题。

---

#### 选择排序算法

选择排序三步走：
1. 找出最小元素
2. 移至数组前端
3. 递归处理剩余N-1个元素

示例数组`{6, 3, 7, 2, 8, 1}`的处理过程：
1. 最小元素1与6交换 → `{1, 3, 7, 2, 8, 6}`
2. 剩余数组找最小2与3交换 → `{1, 2, 7, 3, 8, 6}`
3. 依此类推直至完全有序

基础代码框架：

```java
public class Sort {
    /** 原地排序字符串数组 */
    public static void sort(String[] x) { 
        // 定位最小元素
        // 交换至前端
        // 递归处理剩余元素
    }
}
```

---

#### 最小元素定位

实现`findSmallest`方法：

```java
public class Sort {
    /** 返回数组中最小的字符串索引 */
    public static int findSmallest(String[] x, int start) {
        int smallestIndex = start;
        for (int i = start; i < x.length; i++) {
            if (x[i].compareTo(x[smallestIndex]) < 0) {
                smallestIndex = i;
            }
        }
        return smallestIndex;
    }
}
```

对应测试用例：

```java
public class TestSort {
    @Test
    public void testFindSmallest() {
        String[] input = {"i", "have", "an", "egg"};
        assertThat(Sort.findSmallest(input, 0)).isEqualTo(2);
        
        String[] input2 = {"there", "are", "many", "pigs"};
        assertThat(Sort.findSmallest(input2, 2)).isEqualTo(2);
    }
}
```

---

#### 元素交换

实现安全的元素交换：

```java
public class Sort {
    /** 交换数组元素 */
    public static void swap(String[] x, int a, int b) {
        String temp = x[a];
        x[a] = x[b];
        x[b] = temp;
    }
}
```

测试案例验证交换逻辑：

```java
public class TestSort {
    @Test
    public void testSwap() {
        String[] input = {"i", "have", "an", "egg"};
        Sort.swap(input, 0, 2);
        assertThat(input).isEqualTo(new String[]{"an", "have", "i", "egg"});
    }
}
```

---

#### 递归实现

通过辅助方法实现递归排序：

```java
public class Sort {
    /** 主排序方法 */
    public static void sort(String[] x) {
        sort(x, 0);
    }

    /** 从指定位置开始递归排序 */
    private static void sort(String[] x, int start) {
        if (start == x.length) return;
        int smallest = findSmallest(x, start);
        swap(x, start, smallest);
        sort(x, start + 1);
    }
}
```

调试过程中需注意数组越界等问题，通过单元测试可快速定位异常。

---

#### 测试哲学

**三层验证体系**：
1. 自动化测试工具（如课程评分系统）
2. JUnit单元测试（验证独立模块）
3. 集成测试（验证模块协作）

**测试驱动开发(TDD)**流程：
1. 定义新功能需求
2. 编写对应测试用例
3. 验证测试失败
4. 实现功能代码
5. 重构优化（保持测试通过）

---

#### 测试特性

使用`@Test`注解与动态测试执行：
- 单个绿色箭头执行特定测试
- 双箭头执行全部测试
- IntelliJ提供可视化测试结果面板

![](测试结果示意图)

通过系统化的测试方法，开发者能更高效地构建可靠软件系统，在保证质量的同时提升开发效率。
# 36.4 总结

**基数排序与比较排序。** 在讲座中，我们使用字符检查次数作为成本模型来比较基数排序和比较排序。对于MSD基数排序，最坏情况下每个字符被检查一次，总共检查NM个字符。对于归并排序，最坏情况下检查MNlogN个字符。因此，如果字符比较是合适的成本模型，我们可以看到归并排序慢了一个logN因子。然而，通过实证分析，我们发现这并不成立，原因包括缓存、优化方法、额外复制操作等背景因素，且整体上我们的成本模型未能涵盖所有实际情况。

---

**即时编译器。** “解释器”在代码运行时研究你的代码，因此当一段代码多次运行时，它会基于运行中的学习重新实现以优化性能。例如，如果在一个循环中多次创建LinkedList但未使用，它最终会学会停止创建LinkedList，因为它们从未被使用。当禁用即时编译器时，前一节中的归并排序确实比MSD基数排序慢。

---

**整数基数排序。** 当对整数进行基数排序时，我们不再有charAt方法。有许多替代方案，例如使用模运算和除法编写自定义getDigit()方法，或将每个整数转换为字符串。然而，我们实际上不必局限于基数10，而是可以将数字视为基数16、256甚至基数65536的数。因此，我们可以减少位数，从而降低运行时间，因为基数排序的运行时间取决于字母表大小。
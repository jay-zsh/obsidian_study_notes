
# 36.1 基数排序 vs. 比较排序

---

## 直观分析

### 归并排序时间复杂度
归并排序需要 Θ(N log N) 次比较。  
核心概念：若每次比较耗时恒定，则归并排序对长度为 W 的字符串排序耗时为 Θ(N log N)；若每次比较耗时 Θ(W)，则总耗时为 Θ(WN log N)。  
- Θ(N log N) 示例：字符串首字符均不同  
- Θ(WN log N) 示例：字符串完全相同  

### LSD排序 vs. 归并排序
关键事实（字母表大小视为常数）：  
- LSD排序时间复杂度：Θ(WN)  
- 归并排序时间复杂度：Θ(N log N) 至 Θ(WN log N)  

优劣取决于场景：  

#### LSD排序更快的场景
- 当 W 远小于 N（或 N 极大）  
- 归并排序的最坏情况（字符串高度相似）  
- 字符串相似度极高时  
  - 此时归并排序每次比较耗时为 Θ(W)  

![](PANG/e5fff7f807f33aa6d093e802fd0b2663_MD5.jpg)

#### 归并排序更快的场景
- 字符串差异显著（尤其首字符不同）  
- 字符串高度不相似时  
  - 此时归并排序每次比较极快  

![](PANG/a7db3b36d210273488de42251d0c59bf_MD5.jpg)

---

## 成本模型分析

### 替代方法：选择成本模型
采用**检查字符次数**作为成本模型：  
- 基数排序：为统计字符出现频次调用 charAt  
- 归并排序：为比较字符串调用 charAt  

### MSD排序 vs. 归并排序
假设：100 个长度为 1000 的字符串  

**MSD基数排序（最坏情况：全等字符串）**：  
- 每个字符仅检查一次 → 总检查次数：100,000  
![](PANG/89a7191dc129b243f8305c183010b12e_MD5.jpg)

**归并排序（全等字符串）**：  
- 合并 100 项时，每次比较需检查 2000 个字符  
- 首次合并总检查次数：50 × 2000 = 100,000  
- 完整排序总检查次数：~1000N log₂N ≈ 660,000  
![](PANG/d7f78892a8a3a86abd2a5152827d3588_MD5.jpg)  
![](PANG/f537e2cbbbbda5946854d2f020aa2f44_MD5.jpg)

### MSD与归并排序的字符检查对比
对 N 个长度为 1000 的全等字符串：  
- MSD基数排序：~1000N 次检查（N=100 时：100,000）  
- 归并排序：~1000N log₂N 次检查（N=100 时：660,000）  
若字符检查是合理成本模型，归并排序应慢 log₂N 倍。需通过计算实验验证。  

---

## 实证研究：基数排序 vs. 比较排序

### 计算实验结果（参考答案）
W=100 的计算实验：  
- 使用教材优化实现的 [MSD](https://algs4.cs.princeton.edu/51radix/MSD.java.html) 和 [归并排序](https://algs4.cs.princeton.edu/22mergesort/MergeX.java.html)  

**数据与假设不符的可能原因**：  
- MSD分区时未考虑分治成本  
- 归并排序可能采用 Timsort 优化  
- MSD缓存性能较差  
- 字符串比较时间非线性（但重复操作可能被系统优化）  
- 成本模型未覆盖所有因素  
- **关键问题：即时编译器（JIT）的影响**  

![](PANG/96d36bcaee5fabb3fdd6d44316e60e75_MD5.jpg)  
![](PANG/86873b8c8abea4d2526250c912ca29fc_MD5.jpg)

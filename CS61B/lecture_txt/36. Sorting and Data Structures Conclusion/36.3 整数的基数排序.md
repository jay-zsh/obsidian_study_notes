# 36.3 整数的基数排序  
特邀奥巴马  
奥巴马知道冒泡排序！这太神奇了！  
顺便说一句：32位整数是Java等编程语言中的标准整数，可表示40亿个值。这是我们在哈希（第20章）中学到的内容，也是61C课程的概念！

---
### 以上视频摘要  
巴拉克·奥巴马被问到一个谷歌面试问题：排序一百万个32位整数的最有效方法是什么？奥巴马说他不推荐使用冒泡排序！没错，朋友们！奥巴马精通他的61B课程😄。  

---
### 答案是什么？  
这个问题的答案实际上是基数排序，因为在N极大的情况下，基数排序是最快的，其运行时间为$Θ(WN)$（其中W是数字位数，N是待排序整数数量）。这比我们学过的任何比较排序都快，因为最快的比较排序运行时间仅为$Θ(N \log N)$。  

---
### 但我们如何做到呢？  
我们没有针对每个整数的charAt()方法。如果将整数全部转为字符串，操作也非常耗时。那么如何对整数数组进行LSD基数排序？与其使用charAt，不如编写一个辅助方法如`getDthDigit(int N, int d)`。示例：`getDthDigit(15009, 2) = 5`。  

---
### 整数的LSD基数排序  
注意，我们不必局限于十进制。我们可以增加基数以减少总位数。这已进入61C领域（我们尚未深入讨论整数的二进制表示），但核心思想是转为十六进制（基数为16），使用以下数字表示：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F}。其中A代表10，F代表15（0-15共16种可能值）。将十进制（基数10）转为十六进制（基数16）的方法如下：  
![](7ddd1e67aa099a65af657800bec29e49_MD5.jpg) 
十进制转十六进制  
原始数字在十进制中有6位，而结果仅需5位！我们甚至可扩展到基数256（Ducentohexaquinquagesimal），只需3位！这是微小而惊人的优化！  
![](85738a28b90bad890c40285c809bfa8c_MD5.jpg) 
十进制转Ducentohexaquinquagesimal（基数256）  
请勿记忆“Ducentohexaquinquagesimal”一词。关键点在于：转换到更高基数可减少位数，从而加速LSD和MSD基数排序的遍历。  
然而，整数大小W与计数数组大小间存在权衡。最优解实际是基数256！
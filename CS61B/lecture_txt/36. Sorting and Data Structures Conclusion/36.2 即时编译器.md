# 36.2 即时编译器

Java的即时编译器在代码运行时秘密优化您的代码。

- 您编写的代码不一定是实际执行的代码！
- 当代码运行时，“解释器”会监控所有发生的事件。
  - 如果某段代码被多次调用，解释器会基于运行时观察到的信息（！！）分析和重新实现您的代码。
    - 示例：执行结果未被使用的计算。
    - 若感兴趣，请参阅 this video。

![](5c4337faad1873a35e3804b372b2297d_MD5.jpg)

---

## JIT 示例

以下代码每次创建 1000 个链表。

- 重复此操作 500 次会产生有趣的结果。

![](4cfb7fbf3639bb59a68ff97ce61e4245_MD5.jpg)

- 首次优化：不确定其具体作用。
- 第二次优化：停止创建链表，因为我们实际上未使用它们。

![](3490915091965bbdd4882f99fdec7056_MD5.jpg)

---

## ... 那么哪种更好？MSD 还是归并排序？

归并排序算法的性能高度依赖于即时（JIT）编译的存在。具体而言，当启用 JIT 时，归并排序在待排序字符串相等的情况下更快；但禁用 JIT 时则较慢。这表明，鉴于 JIT 通常启用，归并排序在此特定场景下更有效。然而，还有许多其他场景需考虑，包括几乎相等的字符串、随机字符串以及来自特定数据集的真实数据。在评估归并排序对这些替代场景的有效性时，必须进行仔细的实验和分析，以确定最合适的排序算法。lectureCode 存储库提供了运行这些实验的代码，允许在各种条件下更精确地评估算法性能。最终，实际应用需对真实数据上的不同实现进行彻底分析，以选择最优算法。

---

## 核心结论：算法比较可能很困难

比较具有相同增长阶的算法是一项艰巨任务，因为这需要开展计算实验来确定其相对性能。然而，现代编程环境可能为此过程引入额外挑战，因为某些优化（如 Java 中的即时编译）会影响实验结果。值得注意的是，即使对算法的微小优化也可能显著影响其性能。例如，Vladimir Yaroslavskiy 提出的快速排序算法改进已显示出明显提升，这在快速排序讲座中简要讨论过。因此，在比较具有相似增长率的算法时，必须警惕可能影响性能的潜在优化和变体。

---

## JIT 编译器持续演进

即时（JIT）编译器是现代编译器中高度复杂且关键的组件，也是该领域活跃的研究和发展方向。然而，较旧的 JIT 编译器 C2 已日益难以维护和扩展，近年来未实现重大改进。C2 的代码库采用特定 C++ 方言编写，使新工程师难以理解和修改。因此，该代码库正被弃用，转向更新且更易维护的替代方案。对此领域感兴趣者，可参加 CS164 的编译器课程，并有机会参与持续研究。值得注意的是，归并排序在 JIT 下性能提升的原因尚未完全明确，这使其成为进一步研究的有趣课题。
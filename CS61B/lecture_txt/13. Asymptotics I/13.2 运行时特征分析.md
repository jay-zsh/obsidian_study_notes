# 13.2 运行时间特征化
计算成本测量技术

## 分析目标
我们需要对前文提到的两种算法进行运行时间特征化，建立能够反映算法性能的量化指标。特征化需满足：
1. 方法简单且数学严谨
2. 能清晰展示算法间性能差异

## 算法实现对比
```java
// 朴素算法：全量比对
public static boolean dup1(int[] A) {  
  for (int i = 0; i < A.length; i += 1) {
    for (int j = i + 1; j < A.length; j += 1) {
      if (A[i] == A[j]) return true;
    }
  }
  return false;
}

// 优化算法：相邻比对
public static boolean dup2(int[] A) {
  for (int i = 0; i < A.length - 1; i += 1) {
    if (A[i] == A[i + 1]) return true; 
  }
  return false;
}
```


## 技术方法一：物理计时
通过实际测量程序执行时间（秒级）进行分析：
- 使用物理秒表（不推荐）
- Unix系统time命令
- Princeton标准库的Stopwatch类

**实验发现**：随着输入规模增大，dup1耗时显著增加，而dup2保持稳定

**局限性**：
- 测试耗时随规模指数级增长
- 结果受硬件/编译器/输入数据影响
- 缺乏数学严谨性

## 技术方法二A：操作计数
以N=10000为例统计操作次数：

| 操作类型        | 计数范围          |
|----------------|-------------------|
| i = 0          | 1                 |
| j = i+1        | 1（最优）~10000（最差）|
| < 比较         | 2 ~ 50,015,001    |
| += 1           | 0 ~ 50,005,000    |
| == 比较        | 1 ~ 49,995,000    |
| 数组访问        | 2 ~ 99,990,000    |

**优缺点**：
- 解决硬件依赖性
- 人工计算繁琐
- 输入规模选择具有任意性

## 技术方法二B：符号化计数
引入符号表达式描述操作次数与N的关系：

| 操作类型        | 符号表达式            | N=10000实例        |
|----------------|----------------------|--------------------|
| i = 0          | 1                    | 1                  |
| j = i+1        | 1~N                  | 1~10000            |
| < 比较         | 2~$(N^2+3N+2)/2$     | 2~50,015,001       |
| += 1           | 0~$(N^2+N)/2$        | 0~50,005,000       |
| == 比较        | 1~$(N^2-N)/2$        | 1~49,995,000       |
| 数组访问        | 2~$N^2-N$            | 2~99,990,000       |

**优势**：
- 揭示算法随规模扩展的规律
- 摆脱具体数值限制

**待解决问题**：
- 计算复杂度仍然较高
- 无法直接转换为实际时间
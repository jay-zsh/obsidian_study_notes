# 13.4 渐近行为

---

保持最佳状态！

在大多数应用中，我们最关心当 NN 趋近极大值时的行为表现。这种现象被称为渐近行为。我们需要了解哪些类型的算法能够处理大规模数据。需要高效算法的典型应用场景包括：

- 模拟数十亿粒子的相互作用  
- 维护数十亿用户的社交网络  
- 编码数十亿字节的视频数据

具备良好扩展性的算法，其_渐近_时间复杂度远优于扩展性差的算法。

---

## 重访重复检测函数

让我们回到最初分析`dup`函数运行时间的课题。理想的时间复杂度描述应具备以下特征：

- 简洁且数学严谨  
- 清晰展示dup2相较于dup1的优越性

第二个目标已然实现！我们可以明确看出`dup2`的性能优于`dup1`。但当前的实现方式在简洁性和数学严谨性上仍有改进空间。通过系列简化方法，我们将解决这些问题。

---

## 简化一：仅考虑最坏情况

在算法比较中，通常只需关注最坏情况。最坏情况往往能揭示最本质的特征，因此我们通常可忽略其他情况。

### 案例解析

观察某算法的操作计数表，预测其运行时增长阶数：

操作类型 | 计数
---|---
小于 (<) | 100N² + 3N
大于 (>) | 2N³ + 1
逻辑与 (&&) | 5000

**答案**：N³（立方阶）

直觉上，N³比N²增长更快，具有"主导"效应。进一步论证如下：

- 假设<操作耗时α纳秒，>操作耗时β纳秒，&&操作耗时γ纳秒  
- 总耗时为 α(100N²+3) + β(2N³+1) + 5000γ 纳秒  
- 当N极大时，2βN³项将主导整体耗时  
- 可通过微积分思想理解：当N趋于无穷时，哪项主导整体趋势？

---

## 简化二：聚焦单一代表操作

选择某个代表性操作作为整体运行时间的代理指标。以`dup`函数为例：

- 有效选择：增量操作、比较操作（<、==）、数组访问  
- 无效选择：赋值操作（j = i + 1）、初始化操作（i = 0）

所选操作被称为"**成本模型**"。

---

## 简化三：忽略低阶项

舍弃低阶项。

**合理性验证**：为何可行？（与后续检查点关联）

---

## 简化四：消除乘积常数

忽略乘积常数项。

- 原因：缺乏实际意义  
- 选择单一代表操作时，已舍弃部分信息  
- 不同操作可能具有3N²、N²/2等计数形式，本质上都属于N²家族

---

## 检查点练习

将四项简化规则应用于`dup2`函数分析表：

操作类型 | 符号计数
---|---
i = 0 | 1
j = i+1 | 0 到 N
< | 0 到 N-1
== | 1 到 N-1
数组访问 | 2 到 2N-2

**示例答案**：数组访问的阶数为N。

<、\=\=、j=i+1等操作也可作为有效答案。

---

## 简化原则总结

- 仅考虑最坏情况  
- 选定代表操作（即成本模型）  
- 舍弃低阶项  
- 忽略乘积常数

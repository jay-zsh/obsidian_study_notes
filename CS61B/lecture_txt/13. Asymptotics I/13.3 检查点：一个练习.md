# 13.3 检查点：实践练习

一次亟需的实践训练。

**练习**：对 `dup2` 应用 2A 和 2B 技术：
- 计算以下代码中各项操作相对于 N 的计数
- 预测各项操作的**_大致_**量级

```java
for (int i = 0; i < A.length - 1; i += 1){
  if (A[i] == A[i + 1]) { 
    return true; 
  }
}
return false;
```

---

### 参考答案

注：略有偏差是可以接受的——正如前文所述，我们只需要**_大致_**估算。

| 操作          | 符号计数         | N=10000时的计数  |
|---------------|------------------|------------------|
| i = 0         | 1                | 1                |
| j = i+1       | 0 至 N           | 0 至 10,000      |
| <             | 0 至 N-1         | 0 至 9,999       |
| ==            | 1 至 N-1         | 1 至 9,999       |
| 数组访问      | 2 至 2N-2        | 2 至 19,998      |

"我这里还有另一个问题要考考你 ( ͡° ͜ʖ ͡°)..." —— Josh Hug

---

### 算法对比分析

将 `dup1` 与 `dup2` 的运算表进行对比：

**`dup1` 运算表**：

| 操作          | 符号计数                  | N=10000时的计数  |
|---------------|---------------------------|------------------|
| i = 0         | 1                         | 1                |
| j = i+1       | 1 至 N                    | 1 至 10,000      |
| <             | 2 至 (N²+3N+2)/2         | 2 至 50,015,001  |
| += 1          | 0 至 (N²+N)/2            | 0 至 50,005,000  |
| ==            | 1 至 (N²-N)/2            | 1 至 49,995,000  |
| 数组访问      | 2 至 N²-N                | 2 至 99,990,000  |

**`dup2` 运算表**：

| 操作      | 符号计数     | N=10000时的计数 |
| ------- | -------- | ----------- |
| i = 0   | 1        | 1           |
| j = i+1 | 0 至 N    | 0 至 10,000  |
| <       | 0 至 N-1  | 0 至 9,999   |
| ==      | 1 至 N-1  | 1 至 9,999   |
| 数组访问    | 2 至 2N-2 | 2 至 19,998  |

---

### 核心结论
1. 在最坏情况下，`dup2` 的性能显著优于 `dup1`
2. 算法优化本质：`dup2` 达成相同目标所需的操作更少
3. 更深层认知：抛物线型增长 (N²) 始终快于线性增长 (N)
4. 关键发现：`dup2` 的最坏时间复杂度从 O(N²) 优化至 O(N)
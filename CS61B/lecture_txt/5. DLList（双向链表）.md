
---


## 双向链表核心改进

### 尾部操作优化问题

原始`addLast`方法性能瓶颈：

```java
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {  // 需要遍历整个链表
        p = p.next;
    }
    p.next = new IntNode(x, null);
}
```

### 改进方案：添加last指针

```java
public class SLList {
    private IntNode sentinel;
    private IntNode last;  // 新增last指针
    private int size;
    
    public void addLast(int x) {
        last.next = new IntNode(x, null);
        last = last.next;  // 直接操作last指针
        size += 1;
    }
}
```

|操作|时间复杂度|支持情况|
|---|---|---|
|addLast()|O(1)|✅ 快速添加|
|getLast()|O(1)|✅ 直接访问|
|removeLast()|O(N)|❌ 需要获取倒数第二个节点|

![带last指针的SLList](https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/sllist_last_pointer.png)

## 双向链表结构

### 节点结构升级

```java
public class IntNode {
    public IntNode prev;  // 新增前驱指针
    public int item;
    public IntNode next;
    
    public IntNode(IntNode p, int i, IntNode n) {
        prev = p;
        item = i;
        next = n;
    }
}
```

### 哨兵节点优化方案

#### 方案1：双哨兵节点

```java
public class DLList {
    private IntNode frontSentinel;  // 前哨兵
    private IntNode backSentinel;   // 后哨兵
    private int size;
    
    public DLList() {
        frontSentinel = new IntNode(null, 0, backSentinel);
        backSentinel = new IntNode(frontSentinel, 0, null);
        size = 0;
    }
}
```

![双哨兵结构](https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_double_sentinel_size_0.png)

#### 方案2：循环哨兵节点（推荐）

```java
public class DLList {
    private IntNode sentinel;  // 循环哨兵
    private int size;
    
    public DLList() {
        sentinel = new IntNode(null, 0, null);
        sentinel.next = sentinel;  // 自循环
        sentinel.prev = sentinel;
        size = 0;
    }
}
```

![循环哨兵结构](https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png)

## 泛型实现

### 泛型DLList定义

```java
public class DLList<T> {  // 类型参数<T>
    private Node sentinel;
    private int size;

    private class Node {
        Node prev;
        T item;  // 泛型存储
        Node next;
        
        Node(Node p, T i, Node n) {
            prev = p;
            item = i;
            next = n;
        }
    }
}
```

### 泛型实例化示例

```java
// 字符串链表
DLList<String> strList = new DLList<>(); 
strList.addLast("Hello");
strList.addLast("World");

// 整数链表（使用包装类）
DLList<Integer> intList = new DLList<>();
intList.addLast(5);
intList.addLast(10);
```

|基本类型|包装类|
|---|---|
|int|Integer|
|double|Double|
|char|Character|
|boolean|Boolean|

## 关键特性对比

|特性|单向链表(SLList)|双向链表(DLList)|
|---|---|---|
|节点指针|单指针(next)|双指针(prev/next)|
|尾部删除时间复杂度|O(N)|O(1)|
|内存占用|较小|较大(+33%)|
|实现复杂度|简单|较高|
|哨兵方案|单哨兵|循环哨兵|

## 设计思考题

#练习 如何实现O(1)时间复杂度的removeLast操作？

```answer
方案：维护倒数第二个节点的指针。每次添加新节点时，记录前驱节点：
1. 添加lastPrev指针
2. addLast时更新lastPrev = last
3. removeLast时直接操作lastPrev指针
注意：需要考虑边界条件处理
```

## 实现注意事项

1. **循环不变式**：确保哨兵节点的prev/next始终有效
2. **空列表处理**：哨兵节点应自循环（sentinel.next == sentinel）
3. **指针同步更新**：修改节点时需同时更新相邻节点的指针
4. **泛型擦除**：运行时类型信息会被擦除，需注意类型转换安全

![双向链表操作示意图](https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png)
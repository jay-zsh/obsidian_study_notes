# 10.3 类型转换

---

### 动态方法选择与类型检查谜题

**静态类型与动态类型回顾：**  
Java中每个变量都有静态类型（声明时指定的类型，编译时检查）和动态类型（实例化时指定的类型，运行时检查）。

---

### 编译时类型检查与表达式

编译器根据变量的编译时类型允许方法调用，同时基于编译时类型允许赋值操作。

表达式具有编译时类型：
- 使用`new`关键字的表达式具有指定的编译时类型。例：
```java
SLList<Integer> sl = new VengefulSLList<Integer>();
```
- 右侧表达式编译时类型为`VengefulSLList`
- `VengefulSLList`是`SLList`的子类，允许赋值

```java
VengefulSLList<Integer> vsl = new SLList<Integer>();
```
- 右侧表达式编译时类型为`SLList`
- `SLList`不一定是`VengefulSLList`，编译错误

表达式编译时类型规则：
- 方法调用的编译时类型等于其声明类型

```java
public static Dog maxDog(Dog d1, Dog d2) { ... }
```
- 所有`maxDog`调用均具有编译时类型`Dog`

示例：
```java
Poodle frank = new Poodle("Frank", 5);
Poodle frankJr = new Poodle("Frank Jr.", 15);

Dog largerDog = maxDog(frank, frankJr);  // 允许
Poodle largerPoodle = maxDog(frank, frankJr);  // 编译错误！右侧编译时类型为Dog
```

---

## 类型转换

Java通过强制类型转换语法指定表达式的编译时类型：
- 在表达式前使用括号标注目标类型
- 本质是让编译器暂时"忽略"类型检查规则

类型转换的特性：
- 通知编译器以特定类型处理表达式（类似戴墨镜看世界）
- 不会实际改变对象类型
- 功能强大但存在风险

示例：
```java
Poodle largerPoodle = (Poodle) maxDog(frank, frankJr);  // 强制类型转换
```
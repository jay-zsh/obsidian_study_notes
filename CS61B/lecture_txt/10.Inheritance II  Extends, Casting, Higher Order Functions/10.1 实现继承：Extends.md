# 10.1 实现继承：Extends
---

### 入门指南
---

**核心概念**

### Extends关键字
---
此前我们一直在编写类和接口，你可能已经注意到在不同或相似类中需要编写重复代码的情况。因此我们引入了**继承**的概念：即类/对象无需重新定义所有方法，可以直接使用父类的特性。

当类是接口的下位词时，我们使用implements。**示例如下：**

```java
SLList<Blorp> implements List61B<Blorp>
```

若希望一个类成为另一个类（而非接口）的下位词，则使用extends。

### RotatingSLList
---
我们希望构建能执行所有SLList操作并新增功能的RotatingSLList：rotateRight()：将末尾元素移至前端。

```java
public class RotatingSLList<Blorp> extends SLList<Blorp>{
       public void rotateRight() {
              Blorp oldBack = removeLast();
              addFirst(oldBack);
	}
}
```

通过extends关键字，RotatingSLList继承了SLList的所有成员：
- 所有实例变量和静态变量
- 所有方法
- 所有嵌套类
- **注意**：构造函数不被继承！

**示例**：假设有列表[5, 9, 15, 22]，执行rotateRight后变为[22, 5, 9, 15]。

---

VengefulSLList
---
假设我们需要构建具备以下特性的SLList：
- 记录所有被removeLast删除的条目
- 新增printLostItems()方法输出已删除条目

```java
public class VengefulSLList<Item> extends SLList<Item> {
	private SLList<Item> deletedItems;
	public VengefulSLList() {
       deletedItems = new SLList<Item>();
	}
  
	@Override
	public Item removeLast() {
    		Item oldBack = super.removeLast(); /* 调用父类版本的removeLast() */
    		deletedItems.addLast(oldBack);
    		return oldBack;
	}
 
	public void printLostItems() {
    		deletedItems.print();
	}
}

public static void main(String[] args) {
    	VengefulSLList<Integer> vs1 = new VengefulSLList<Integer>();
    	vs1.addLast(1);
    	vs1.addLast(5);
    	vs1.addLast(10);
    	vs1.addLast(13);      /* [1, 5, 10, 13] */
    	vs1.removeLast();     /* 删除13 */
    	vs1.removeLast();     /* 删除10 */
    	System.out.print("被删除的条目：");
    	vs1.printLostItems(); /* 应输出10和13 */
}
```

### 构造函数行为
---
构造函数**不被继承**。根据Java规范，所有构造函数必须首先调用父类构造函数.

- 核心思想：如果每个VengefulSLList都是SLList，则必须按SLList的方式初始化
- 可通过super关键字显式调用父类构造函数（不加点号）

以下两种构造函数完全等效：

```java
public VengefulSLList() {
   deletedItems = new SLList<Item>();
}

public VengefulSLList() {
   super();
   deletedItems = new SLList<Item>();
}
```

但带参数的构造函数需要注意：下方第二个构造函数隐式调用super()而非super(x)

```java
public VengefulSLList(Item x) {
   super(x);
   deletedItems = new SLList<Item>();
}

public VengefulSLList(Item x) {
   deletedItems = new SLList<Item>();
}
```

### 从属关系辨析
---
关键提示：**extends**应仅用于**is-a**（上下位）关系！

常见错误是将其用于"has-a"（整体-部分）关系：
- 虽然技术上可以通过继承SLList实现集合类，但概念上存在问题（例如get(i)对无序集合无意义）

### Object类
---
Java中所有类型都是Object类的后代：
- VengefulSLList继承SLList
- SLList隐式继承Object

Object类文档：[Object (Java SE 9 & JDK 9 )](https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html)

**抽象化理念**：随着程序规模扩大，复杂度可能骤增。通过抽象化（隐藏非必要实现细节）可以有效管理复杂度，使用者无需了解方法具体实现即可调用。
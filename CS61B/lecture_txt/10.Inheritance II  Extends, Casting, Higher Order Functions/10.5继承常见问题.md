# 10.5 练习题

---

## 事实题

1. 已知`maxDog`方法签名如下：

```java
public static Dog maxDog(Dog d1, Dog d2) { ... }
```

当执行以下代码时，`Dog.maxDog(dogC, dogD)`的静态类型是什么？

```java
ShowDog dogC = new ShowDog("Franklin", "Malamute", 180, 6);
ShowDog dogD = new ShowDog("Gargamel", "Corgi", 44, 12);

Dog.maxDog(dogC, dogD);
```

2. 下列哪行代码能编译通过？

```java
Dog md = Dog.maxDog(dogC, dogD);
ShowDog msd = Dog.maxDog(dogC, dogD);
```

3. 在以下代码中，`o`、`d`、`stuff[0]`和`stuff[1]`的动态类型分别是什么？

```java
Object o = new Dog("Hammy", "Beagle", 15);
Dog d = new ShowDog("Ammo", "Labrador", 54);
Object stuff[] = new Object[5];
stuff[0] = o;
stuff[1] = d;
stuff[2] = null;
```

---

### 问题1解析
静态类型为`Dog`，即`maxDog`方法声明的返回类型。

---

### 问题2解析
仅第一行能编译。`maxDog`的静态返回类型是`Dog`（`ShowDog`的父类），编译器认为返回值对变量`msd`的声明类型来说过于宽泛。

```java
Dog md = Dog.maxDog(dogC, dogD);
// ShowDog msd = Dog.maxDog(dogC, dogD); // 编译失败
```

---

### 问题3解析
- `o`: `Dog`（实例化为犬类）
- `d`: `ShowDog`（实例化为展示犬）
- `stuff[0]`: `Dog`（指向与`o`相同的对象）
- `stuff[1]`: `ShowDog`（指向与`d`相同的对象）

---

## 概念题

1. 接口能否继承类？请说明理由。
2. `extends`与`implements`的核心区别是什么？分别在何种场景下使用？

---

### 问题1解析
Java不允许接口继承类。概念上，类包含方法实现而接口仅定义规范，接口无法继承类的实现细节。

---

### 问题2解析
核心区别：
- `extends`继承实现，允许子类复用父类代码
- `implements`定义契约，要求实现特定方法

使用场景：
- 需要复用代码时用`extends`
- 需要多继承或定义行为规范时用`implements`

---

## 程序题

1. 贵宾犬类`Poodle`继承自`Dog`类，现有以下实现是否有效？如何修正？

```java
// 犬类定义
public class Dog {
  int weight;
  public Dog(int weight_in_pounds) {
    weight = weight_in_pounds;
  }
}

// 贵宾犬类定义
public class Poodle extends Dog {
 public Poodle() {} // 编译错误
}
```

2. 当尝试将`Monkey`对象强制转换为`Dog`类型时会发生什么？

```java
Monkey jimmy = new Monkey("Jimmy");
Dog limmy = (Dog) jimmy; // 编译错误
```

3. 以下代码能否通过编译？运行时会如何？

```java
Monkey orangutan = new Monkey("fruitful");
Dog mangotan = ((Dog) ((Animal) orangutan)); // 编译通过，运行时报ClassCastException
```

---

### 问题1解析
无效。修正方案：
1. 为`Dog`类添加无参构造器
2. 修改`Poodle`构造器：`public Poodle(int w) { super(w); }`

---

### 问题2解析
编译失败，兄弟类（同父但无继承关系）之间禁止强制转换。

---

### 问题3解析
编译通过但运行时报错：`Monkey`与`Dog`无继承关系，动态类型校验失败。

---

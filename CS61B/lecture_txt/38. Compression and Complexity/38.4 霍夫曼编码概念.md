# 38.4 霍夫曼编码概念
---

## 核心思想

霍夫曼编码采用自底向上的方法构建前缀无关码，与香农-范诺编码的自顶向下方法相反。算法步骤如下：
- 计算相对频率
    - 为每个符号分配节点，权重=相对频率
    - 取两个最小节点合并为超节点，权重等于权重之和
    - 重复直至所有元素构成一棵树

![](PANG/aeb0ee6a7d51fa3faea08b9636e9e823_MD5.jpg)  
霍夫曼编码：分步示例（第一部分）

![](PANG/81f3923f516dc657a7c67cbcc6cadc84_MD5.jpg)  
霍夫曼编码：分步示例（第二部分）

---
## 数据结构

现在探讨霍夫曼编码编解码过程中使用的数据结构。编码将符号转换为码字，解码则执行相反操作。示例如下：
- 编码将 `I ATE` 转换为 `0000011000100101.`
- 解码将 `0000011000100101` 转换为 `I ATE`

### 编码（比特流到压缩比特流）的数据结构
两种可选方案：
1. **哈希映射/树映射**：创建字符到位序列的映射，调用 `get()` 方法查找字符
2. **数组**：数组索引代表字符（如 `A` 对应 ASCII 值 `65`），槽位存储位序列

差异：数组速度更快，但若索引未充分利用则内存效率较低

### 解码（压缩比特流还原为比特流）的数据结构
唯一高效的数据结构可查找比特流的最长前缀：
**字典树（Trie）**：使用二进制字典树（数字0和1），便于查找比特流的最长前缀

![](PANG/4ad9c8eeb4db60a6f3f83f04171aed67_MD5.jpg)

---
## 实践应用
### 语料库方案
- 针对每种输入类型（英文文本、中文文本、图像），收集大量样本输入，建立标准编码方案
- 语料库是语言样本的集合。例如指定使用 `ENGLISH` 语料库压缩 `mobydick.txt`：

```bash
$ java HuffmanEncodePh1 ENGLISH mobydick.txt
```

**问题**：次优编码——语料库与输入不完全匹配。本例中 `mobydick.txt` 可能偏离 `ENGLISH` 文本的通用频率特征，包含作者的特殊用词偏好

### 唯一编码方案
- 为每个输入文件创建专属编码，随压缩文件发送解码方案
- 如下例所示，不指定语料库，额外发送辅助解码文件：

```bash
$ java HuffmanEncodePh2 mobydick.txt
```

**问题**：需在压缩比特流中占用额外空间存储码表。但实际效果通常优于语料库方案，故广泛应用于现实场景

---
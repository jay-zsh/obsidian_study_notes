
# 38.8 练习

---

## 事实性问题

1. 假设我们为本题文本（包括空格和标点符号）构建香农-范诺编码或霍夫曼编码。哪些字符的编码长度会最长？  
2. 在Java中表示字符霍夫曼编码的两种方式是什么？

问题1  
`?` 和 `.`，因为这两个字符在上文中均仅出现一次。

问题2  
`HashMap<Character, BitSequence>` 或 `BitSequence[]`。注意在Java中两者等价，因为Character本质是数字。

---

## 程序性问题

1. 假设字符串 `abcdefg` 重复1000次。压缩后的比特流将包含多少比特？

问题1  
由于所有8个字符频率相同，霍夫曼编码会生成平衡二叉树，因此所有码字均为3比特长。1000 × 8 × 3 = 24000比特。

---

## 元认知问题

1. 利用自提取比特思想，设计一种对重复1000次的序列 `abdefg` 的编码方案，使其使用少于2000比特。

问题1  
自提取比特思想需编写能生成原始序列的解码程序。可通过以下代码实现：

```
public class Sequence {
    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            for (int j = 0; j < 8; j++) {
                System.out.print(String.format("%c", 'a' + j));
            }
        }
    }
}
```

此代码精确占用239字符（1912比特）。这展示了自提取比特模型的强大：对比霍夫曼编码所需的24000比特。

[上一章 38.7 总结](https://cs61b-2.gitbook.io/cs61b-textbook/38.-compression-and-complexity/38.7-summary)  
[下一章 39. 压缩、复杂度与P=NP问题](https://cs61b-2.gitbook.io/cs61b-textbook/39.-compression-complexity-p-np)

最后更新于2年前

38.8 练习 | CS61B 教材

# 38.2 前缀码

考虑Java中英语文本的表示。我们将文本表示为字符序列，每个字符占用8位内存。

一种简单的压缩方法是每个字符使用少于8位。为此，我们必须决定哪些**码字**（比特序列）对应每个**符号**（字符）。

---

## 映射字母数字符号

---

### 摩尔斯电码

作为介绍性示例，考虑摩尔斯电码字母表。看下面的字母表，序列 – – • – – • 代表什么？它是模糊的！相同的符号序列可以代表MEME或GG，取决于你选择 – – • 代表什么。

![](PANG/996df373477624e54540c45887fa9823_MD5.jpg)

摩尔斯电码中的歧义

在真实使用中，操作员必须在码字之间暂停以表示中断。暂停充当隐式的第三个符号，但我们不能将此实时信息编码到我们的代码中。

---

### 前缀码

避免需要实时信息的替代策略是使用**前缀码**。在前缀码中，没有码字是任何其他码字的前缀。在摩尔斯电码示例中，就不会混淆模式 – – • – – • 中的 – – 是代表M，还是G的开始。

让我们将摩尔斯电码表示为符号的码字树。从树中我们可以看到，几个符号的表示是其他符号的前缀。

![](PANG/01114987f11a8833c434bc66d24a1d66_MD5.jpg)

摩尔斯电码不是前缀码。

作为一个（任意的）前缀码示例，考虑以下编码：

![](PANG/6d9d0d022e1f34d510a0ce0befae3b97_MD5.jpg)

一种前缀码。

以下代码也是前缀码：

![](PANG/17c3321547b0f8d895c54abd5a3f9467_MD5.jpg)

另一种前缀码。

注意，某些代码对某些字符串比其他代码更高效：在第一个表示中，`I ATE` 使用的比特比第二个代码少。然而，这高度依赖于我们试图编码的字符串。
# 15.1 For循环

计数，计数，继续计数...

通过前期的运行时分析基础，现在让我们深入研究更复杂的案例。本节目标是通过大量实践掌握运行时分析的模式与方法论。这个领域存在诸多思维陷阱，因此充分的训练至关重要。

---

## 示例一：重复元素检测

我们曾讨论过检测列表中首次重复元素的函数`dup1`：

```java
int N = A.length;
for (int i = 0; i < N; i += 1)
   for (int j = i + 1; j < N; j += 1)
      if (A[i] == A[j])
         return true;
return false;
```

分析其运行时的两种方法：

### 方法一：操作计数法
聚焦于核心操作——元素比较（"=="）的执行次数。外层循环每执行一次，内层循环的执行次数呈等差数列递减：

$$
C = (N-1) + (N-2) + \cdots + 1 = \frac{N(N-1)}{2}
$$

该式属于$N^2$量级，故最坏情况时间复杂度为$\Theta(N^2)$。

### 方法二：几何建模法
将比较操作映射到二维坐标系（i,j）中，形成边长为$N-1$的直角三角形区域。由于三角形面积与$N^2$成正比，再次验证时间复杂度为$\Theta(N^2)$。

![[e1e15ec8a67d6bd61a919471c3d120ac_MD5.jpg]]

---

## 示例二：指数增长的循环结构

分析以下含指数增长循环的代码：

```java
public static void printParty(int N) {
   for (int i = 1; i <= N; i = i * 2) {
      for (int j = 0; j < i; j += 1) {
         System.out.println("hello");   
         int ZUG = 1 + 1;
      }
   }
}
```

### 运行模式解析
当$N=1$时输出1次，$N=2$时累计3次，$N=3$时仍为3次（因外循环在i=4时终止）。推广至$N=2^k$的情况，输出次数构成几何级数：

$$
C(N) = 1 + 2 + 4 + \cdots + N = 2N - 1
$$

### 双重验证法
**图形界标法**：绘制输出次数随N增长曲线，可见其始终介于0.5N与4N之间，符合线性增长特征。

**数学推导法**：通过等比数列求和公式严格证明时间复杂度为$\Theta(N)$。

![[427882dbdbde0b1548138eca76f6c95c_MD5.jpg]]

---

## 方法论精要

运行时分析没有银弹，但掌握以下工具可显著提升效率：
1. **精确求和**：运用等差数列与等比数列公式
2. **实例推演**：通过具体案例归纳规律
3. **可视化建模**：将抽象过程转化为几何图形

两类关键级数需熟记：
- **自然数级数**：$\sum_{k=1}^Q k = \frac{Q(Q+1)}{2} \in \Theta(Q^2)$
- **几何级数**：$\sum_{k=0}^{\log_2 N} 2^k = 2N-1 \in \Theta(N)$

![[7cc38472f45993a1eeffa4cd620ec57b_MD5.jpg]]
# 15.2 递归

我们又回到了这个主题...

在掌握了几种嵌套循环结构后，让我们重新审视这个令人着迷的课题：递归。

考察以下递归函数`f3`：

```java
public static int f3(int n) {
   if (n <= 1) 
      return 1;
   return f3(n-1) + f3(n-1);
}
```

#### 函数功能解析

以`f3(4)`的调用过程为例：

- 初始调用将返回`f3(3) + f3(3)`
    
- 每个`f3(3)`调用会进一步分解为`f3(2) + f3(2)`
    
- 当执行到`f3(1)`时，触发终止条件`n <= 1`，返回1
    
- 最终1会被累加8次，即存在8次`f3(1)`调用
    
- 因此`f3(4)`的返回值为8
    

该过程可用递归调用树可视化，各层节点值代表函数参数：

![[PANG/85c6f1fa54a4332e74a2b8c571842d68_MD5.jpg]]

函数f3的递归调用树

通过更多实例验证，可得函数返回值为$$2^{N-1}$$。递归可视化技术对于理解函数行为至关重要，下文将探讨三种递归时间复杂度分析方法。

---

### 方法一：直观推断

观察递归树可以发现，参数n每增加1，计算量即翻倍：

![[PANG/db00065e6331c11188abe97f05e00706_MD5.jpg]]

当参数n经过N次增量后，计算量将经历N次翻倍，由此直观推断时间复杂度为$$O(2^N)$$。

---

### 方法二：代数推导

通过统计递归调用次数进行分析。根据递归树结构，各层的函数调用次数等于该层的节点数量。例如：

- 顶层调用次数：1
- 第二层：2
- 第三层：4
- 以此类推

总调用次数可表示为等比数列求和：

$$C(N) = 1 + 2 + 4 + ... + 2^{N-1}$$

应用等比数列求和公式：

$$1 + 2 + 4 + ... + Q = 2Q - 1$$

令$$Q = 2^{N-1}$$，可得：

$$C(N) = 2(2^{N-1}) - 1 = 2^N - 1$$

由于单次调用时间复杂度为常数级，因此函数整体时间复杂度为$$\Theta(2^N)$$。

---

### 方法三：递推关系（扩展内容）

该方法超出课程要求，仅作兴趣拓展。

建立递推方程：

$$
\begin{align*}
C(1) &= 1 \\
C(N) &= 2C(N-1) + 1
\end{align*}
$$

通过递推展开（具体方法可参考相关资料），最终可得相同结论$$C(N) = 2^N - 1$$，对应时间复杂度$$\Theta(2^N)$$。
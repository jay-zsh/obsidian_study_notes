# 15.3 二分查找

高低法！

## 二分查找简介

### 熟悉二分查找
二分查找是一种在有序列表中高效查找特定元素的算法。其核心原理是利用列表的有序性进行快速定位。

算法流程如下：
1. 从列表中间位置开始比较
2. 若中间元素等于目标值，则查找成功
3. 若中间元素大于目标值，则在左半区继续查找
4. 若中间元素小于目标值，则在右半区继续查找
5. 重复上述过程直到找到目标或确定不存在

最坏情况时间复杂度发生在目标元素不存在时，此时需要遍历所有可能的区间划分层次。

动态演示请参考[这些幻灯片](https://docs.google.com/presentation/d/1P4HKmsO3Aaugv7_U16jJN0UbfTEJi1uZUdi_WbIIGe0/edit#slide=id.g463de7561_042)。

---

## 时间复杂度直观分析
每次操作将搜索范围减半，时间复杂度可表示为：
$$ T(N) = \log_2 N $$

具体推导过程：
1. 初始范围：N 个元素
2. 第一次划分：N/2
3. 第二次划分：N/4
4. ...
5. 最终：1 个元素

总操作次数为 $\lfloor \log_2 N \rfloor + 1$。由于每次操作耗时恒定，整体时间复杂度为：
$$ \Theta(\log N) $$

---

## 精确时间复杂度分析
### 数学证明
定义成本模型为递归调用次数，经验数据如下表：

| N  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |
|----|---|---|---|---|---|---|---|---|---|---|----|----|----|
| 比较次数 | 1 | 2 | 2 | 3 | 3 | 3 | 3 | 4 | 4 | 4 | 4 | 4 | 4 |

精确公式：
$$ C(N) = \lfloor \log_2 N \rfloor + 1 $$

---

### 对数复杂度特性
三个重要性质：
1. $\lfloor f(N) \rfloor = \Theta(f(N))$
2. $\lceil f(N) \rceil = \Theta(f(N))$
3. $\log_p N = \Theta(\log_q N)$

证明示例（性质1）：
$$ f(N) - \frac{1}{2} < \lfloor f(N) + \frac{1}{2} \rfloor \leq f(N) + \frac{1}{2} $$
由于常数项在渐进分析中可以忽略，得证。

---

## 对数时间复杂度优势
实际性能对照表：

| N                  | $\log_2 N$ | 典型耗时（纳秒） |
|---------------------|------------|----------------|
| 100                | 6.6        | 1              |
| 100,000            | 16.6       | 2.5            |
| 100,000,000        | 26.5       | 4              |
| 100,000,000,000    | 36.5       | 5.5            |
| 100,000,000,000,000| 46.5       | 7              |

数据规模增长万亿倍，耗时仅增加约7倍！这完美诠释了对数时间复杂度在大规模数据处理中的卓越性能。
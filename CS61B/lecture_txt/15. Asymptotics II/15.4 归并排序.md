# 15.4 归并排序

---

在最后一个案例中，我们将分析另一种高效的排序算法——归并排序。

---

### 归并排序基础：合并两个有序列表

首先回顾选择排序，这是构建归并排序的基础算法：

选择排序包含两个基本步骤：
1. 在未排序元素中找到最小值，将其移至前端并"固定"
2. 对剩余未固定元素递归执行选择排序

选择排序的运行时间为 $$Θ(N^2)$$。

**练习**：通过几何分析法（绘制每次排序时列表状态）或操作计数法，验证选择排序的 $$Θ(N^2)$$ 时间复杂度。

---

### 任意时间单位概念
虽然实际运行时间受机器性能影响，但可通过**任意时间单位（AU）**建立相对时间模型：
- N=6 时选择排序耗时约 36 AU
- N=64 时耗时约 2048 AU

---

### 高效合并策略
当合并两个**已排序**数组时，可充分利用其有序性：
1. 比较两列表首元素，取较小值放入新列表
2. 重复此过程直至任一列表为空
3. 将剩余元素直接追加

[点击此处查看合并动画演示](https://docs.google.com/presentation/d/1mdCppuWQfKG5JUBHAMHPgbSv326JtCi5mvjH1-6XcMw/edit#slide=id.g463de7561_042)

合并操作的运行时间为 $$Θ(N)$$（以写入操作为成本模型）。

---

### 归并排序的优化路径
通过分层策略提升效率：
1. 将列表二分递归处理
2. 合并子列表时利用线性时间优势

计算示例：
- N=64 时总耗时 = 2*(32²) + 64 = 1088 AU（相比选择排序节省 47%）

**练习**：计算二次分层（N=16）的总耗时约 640 AU。

---

### 归并排序核心逻辑
当列表长度为1时直接返回，否则：
1. 递归排序左半区
2. 递归排序右半区 
3. 合并结果

---

### 时间复杂度分析
分层合并模型：
- 顶层合并：N AU
- 第二层：2*(N/2) = N AU
- 第三层：4*(N/4) = N AU
- ...
- 总层数：$$log_2(N)$$

最终时间复杂度为 $$Θ(N \cdot logN)$$，显著优于 $$Θ(N^2)$$。

![](https://cs61b-2.gitbook.io/~gitbook/image?url=https%3A%2F%2Fjoshhug.gitbooks.io%2Fhug61b%2Fcontent%2Fassets%2Ftimetable.png&width=768&dpr=4&quality=100&sign=94353876&sv=2)

**练习**：精确计算非对称分割场景下的时间复杂度，验证 $$Θ(N \cdot logN)$$ 的普适性。
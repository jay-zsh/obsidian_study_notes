# 21.3 优先队列实现

---
实现方案  
采用与前一章末尾相似的数组表示法，但预留数组首位空白以简化计算：  
- 左子节点：$k*2$  
- 右子节点：$k*2+1$  
- 父节点：$k/2$  

---

实现方案对比  

| 方法          | 有序数组 | 平衡BST  | 哈希表   | 堆结构     |
|---------------|----------|----------|----------|------------|
| add           | $\Theta(N)$ | $\Theta(logN)$ | $\Theta(1)$ | $\Theta(logN)$ |
| getSmallest   | $\Theta(1)$ | $\Theta(logN)$ | $\Theta(N)$ | $\Theta(1)$ |
| removeSmallest| $\Theta(N)$ | $\Theta(logN)$ | $\Theta(N)$ | $\Theta(logN)$ |

优势说明：  
1. 堆操作采用均摊分析（需处理数组扩容）  
2. 若BST存储最小元素指针，getSmallest可达$O(1)$  
3. 基于数组的堆比1A方法（直接子节点指针）节省约2/3内存  

---

待解决问题  
**习题13.3.1**：  
1. 优先队列如何确定排序标准？例如存储Dog对象时，按weight还是breed排序？  
2. 如何实现灵活的排序规则？  
3. 如何将MinPQ改造成MaxPQ？  

# 24.3 A\*算法

Hug教授关于最短路径的讲座

---

## A*

我们在Dijkstra算法部分的结尾讨论了一种可能的优化：当算法命中特定目标节点时立即终止（短路机制）。这足够高效吗？

要回答这个问题，需要深入理解Dijkstra的工作原理。形象地说，Dijkstra以源节点为圆心（想象源节点位于同心圆中心），以递增半径绘制同心圆，并逐层"扫描"这些圆来捕获节点。

Dijkstra首先访问距离源节点最近的城市，然后是次近的，依此类推。它本质上按距离单位递增的顺序访问节点：先访问1单位距离内的节点，再访问2单位距离的节点，形成同心圆扩散。

设想以下场景：在美国地图上，从丹佛出发寻找通往纽约的路径。Dijkstra将按"最近同心圆"顺序遍历节点。

![[PANG/055fefed5f94aa63c50babdcc6760c01_MD5.jpg]]

算法会先在丹佛周围形成小圆，访问该圆内所有城市。随后圆半径增大，会经过拉斯维加斯（此时已访问圆内所有城市）。接着圆继续扩大至覆盖洛杉矶和达拉斯...但仍未接近纽约。如此多计算资源消耗在远离目标的节点上。短路机制虽有帮助，但前提是能快速命中目标节点。

若存在利用先验知识的方法该多好：既然纽约位于东方，就能"引导"算法优先探索东部节点而非西部节点。

---

## 介绍：A\*算法

注意关键区别：Dijkstra测量的是从源节点**到**当前节点的**真实**距离。例如从丹佛访问伊利诺伊州某城市时，已精确知道该节点到丹佛的距离。我们缺少的是从当前节点**到**目标节点（纽约）的**粗略估计值**。若将两者相加（源节点到当前节点的真实距离 + 当前节点到目标的估计距离），就能得到源节点到目标的估计距离。显然，对目标距离的估计越准确，A*算法效率越高。

因此我们微调Dijkstra：原本使用**bestKnownDistToV**作为优先级，现在改用**bestKnownDistToV+estimateFromVToGoal**作为启发值。

---

## 鸡与蛋问题

这里存在悖论：如何预先知道估计值？估计值本身是**距离**，而A*正是用来**计算**节点间距离的。

这如同经典的"鸡生蛋"问题。实际上，我们称其为"估计"正是因为其近似性。设计优质估计函数有时颇具挑战。

以丹佛-纽约为例：可查询GPS坐标计算直线距离。虽然实际路径不可能是直线，但这是合理的估计！

---

## 不良启发式

假设丹佛到纽约的最短路径需经过城市CC，而GPS故障导致我们认为CC到所有节点的估计距离为∞。

后果如何？A*永远不会访问该城市（优先级始终为∞）。最终算法失效，返回错误路径。

关键启示：启发式必须满足两个质量条件：
1. **可采纳性**：heuristic(v, target) ≤ trueDistance(v, target)  
   （前例违反此条件：邻居到CC的真实距离非∞）
2. **一致性**：对w的每个邻居v满足：  
   heuristic(v, target) ≤ dist(v, w) + heuristic(w, target)  
   （其中dist(v, w)表示v到w的边权）
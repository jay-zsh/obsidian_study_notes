
# 24.4 总结

---

**Dijkstra算法与单源最短路径**  
假设需要记录从某源点到所有其他顶点的最短路径（以便快速获取s→X、s→Y等路线）。若仅考虑边数，广度优先搜索（BFS）即可解决。  

但当边具有权重（如道路长度）时，需采用其他方法。即使考虑边权，我们仍能高效预处理源点到各顶点的最短路径——存储为"最短路径树"（SPT）。通常，SPT以edgeTo[]数组存储（若需常数时间distTo()操作，可额外添加distTo[]数组）。  

构建SPT可使用Dijkstra算法，其核心是按**距源点距离递增**的顺序访问顶点，每次访问时松弛所有边。松弛边的本质是：若新路径更优则更新目标顶点距离，否则忽略。伪代码如下：  

```
Dijkstra(G, s):
    while not every vertex has been visited:
        visit(unmarked vertex v for which distTo(v) is minimized)
```

其中visit操作：  
```
visit(v):
    mark(v)
    for each edge e of s:
        relax(e)
```

松弛操作：  
```
relax(e):
    v = e.source
    w = e.target        
    currentBestKnownWeight = distTo(w)
    possiblyBetterWeight = distTo(v) + e.weight
    if possiblyBetterWeight < currentBestKnownWeight
        Use e instead of whatever we were using before
```

时间复杂度为$O(E \log V)$（因$E > V$）。详见课程幻灯片分析。  

---

**A*单目标最短路径**  
若仅需源点到单个目标的路径，Dijkstra算法因探索过多无关边而低效（例如丹佛到纽约的路线中，会扫描目标周围上千英里外的节点）。  

解决方案是对Dijkstra进行微调：访问顺序改为按**distTo(v) + h(v)** 排序，其中h(v)为启发函数。伪代码如下：  

```
A*(G, s):
    while not every vertex has been visited:
        visit(unmarked vertex v for which distTo(v) + h(v) is minimized)
```

可证明（课堂未推导）：只要$h(v) \leq$ 真实距离，A*结果必然正确。  

> 注：课堂版本未显式使用"标记"，而是将所有顶点加入优先队列（PQ），离开PQ的顶点视为已访问。
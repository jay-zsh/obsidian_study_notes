
# 24.2 Dijkstra算法

---

## Hug教授的最短路径讲座

在[第23.1章]中，我们实现了BFS和DFS。我们讨论了使用BFS寻找最短路径树的方法，但当图的边具有权重时，BFS将失效。

考虑以下示例：你在校园里与朋友在Hearst纪念矿业大楼周围玩游戏。你从位置`s`出发，想要到达位置`t`。

![校园路径示意图](https://cs61b-2.gitbook.io/cs61b-textbook/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FxzpKygRCaSkngJwoCLdT%252Fdj.png%3Falt%3Dmedia%26token%3D5ea88ee0-a3f3-4fbb-abe3-8d73c7e47ed8&width=768&dpr=4&quality=100&sign=716bb574&sv=2)

BFS将产生330米的路径而非最优解，因此我们需要考虑边距离（即"边权重"的算法。

![正确结果](https://cs61b-2.gitbook.io/cs61b-textbook/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FGI1nX4Nm3ZAUc9kaw7Ob%252Fimage1.png%3Falt%3Dmedia%26token%3D5db1c532-bfe6-4079-8777-885479aeeab0&width=768&dpr=4&quality=100&sign=f0718829&sv=2)

![BFS结果](https://cs61b-2.gitbook.io/cs61b-textbook/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FPFJWmPg62SiIO5bk1wtI%252Fimage2.png%3Falt%3Dmedia%26token%3De49217f2-d064-472a-b705-2fa01052f875&width=768&dpr=4&quality=100&sign=348c9f93&sv=2)

---

### 关键观察

需注意：对于含权边的图，最短路径可能包含多条边。我们需最小化所选路径的边权重总和。

其次，从源点`s`出发的最短路径树可通过以下方式构建：
- 为图中每个非`s`顶点`v`，找到从`s`到`v`的最短路径
- 合并上述所有找到的边

第三，最短路径树**始终是树**。原因在于：原始解决方案中维护的`edgeTo`数组为每个节点指定唯一"父节点"（树具有`V-1`条边，`V`为节点数）。

---

### Dijkstra算法

该算法输入源顶点`s`，输出从`s`出发的最短路径树。其工作流程：
1. 创建优先队列
2. 将`s`以优先级0加入队列，其他顶点以优先级∞加入
3. 当队列非空时：弹出顶点，并**松弛**其所有出边

---

### **松弛**操作的含义

设从队列弹出的顶点为`v`。考察`v`的所有边（如边`(v,w)`）。松弛该边的过程：
1. 获取当前到`w`的最优距离 **curBestDistToW**
2. 计算 **curBestDistToV** + `weight(v,w)` → **potentialDistToWUsingV**
3. 若 **potentialDistToWUsingV** < **curBestDistToW**：
   - 更新 **curBestDistToW = potentialDistToWUsingV**
   - 设置 **edgeTo[`w`] = `v`**

**关键：永不松弛指向已访问顶点的边**

---

### 伪代码实现

```python
def dijkstras(source):
    PQ.add(source, 0)
    For all other vertices, v, PQ.add(v, infinity)
    while PQ is not empty:
        p = PQ.removeSmallest()
        relax(all edges from p)
```

```python
def relax(edge p,q):
   if q is visited (i.e., q is not in PQ):
       return

   if distTo[p] + weight(edge) < distTo[q]:
       distTo[q] = distTo[p] + w
       edgeTo[q] = p
       PQ.changePriority(q, distTo[q])
```

**保证条件**：当所有边权非负时，Dijkstra算法保证最优性。

---

### 证明与直观解释

假设所有边权非负：
1. 初始时`distTo[source]=0`（最优）
2. 松弛`s`的所有边后，设`v₁`为最小权顶点（最接近源点）
   - **断言**：`distTo[v₁]`已最优
   - 反证：若存在更短路径`(s, vₐ, v_b, ..., v₁)`，则`(s, vₐ)`必大于`(s, v₁)`（与`v₁`最小权矛盾）
3. 归纳证明后续弹出顶点均满足最优性

---

### 负权边问题

负权边将导致算法失效。考察下图：

![负权边问题示例](https://cs61b-2.gitbook.io/cs61b-textbook/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FHwPMHevk4XVzaycft4nL%252Fimage.png%3Falt%3Dmedia%26token%3D78ff03ab-25af-4f37-b4bd-1add7021165b&width=768&dpr=4&quality=100&sign=8a49b090&sv=2)

顶点34尝试松弛至33的边（权-67），但33已访问故不松弛，导致错误保留距离82（实际应为34）。

![负权边错误结果](https://cs61b-2.gitbook.io/cs61b-textbook/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FuQcIYrjQT6Psn98MNxFp%252Fimage.png%3Falt%3Dmedia%26token%3D442e9801-9cb0-4aee-9adc-d080f21acb42&width=768&dpr=4&quality=100&sign=fc723251&sv=2)

**Dijkstra算法不保证负权边的正确性**。

思考：若负权边仅从源点`s`出发，算法是否有效？为什么？

---

### 重要不变性

顶点一旦弹出队列，其距离永不更新→弹出时已知真实最短距离。

此性质支持"短路"优化：若仅需源点到特定目标`t`的路径（如伯克利到奥克兰），可在`t`弹出时立即终止算法并返回结果。